###电子书网址

作者：Ruan 

https://www.epubit.com/bookDetails?id=UB7209840d845c9&recommenderCode=2828799y



## 第二章：开始学习C++

###2.1 进入C++

#### 2.1.1 main函数

**c++函数结构**

```c++
#include <iostream>
using namespace std;             //函数头部分，是函数与程序其他部分的一个接口


int main(){
                                 //函数体部分，指出了这个函数要做什么事情
    
    
    
    return 0;                     //返回语句  ，表示该函数结束
}
```

在运行c++程序的时候，通常是从main函数开始的，main函数被启动代码调用，而启动代码是由编译器添加到程序中的，是程序与操作系统之间的桥梁。

所有c++程序必须包含一个main()

> 这里插入一下void和空白的用法

在c++中，void就是空白，空白就是void

***

#### 2.1.2 C++注释

常见的注释方法：  <code>//</code>

C风格注释: <code>* 包含需要注释掉的内容 *</code>    优点：可以跨越多行

***

#### 2.1.3 C++预处理器和iostream文件

预处理器负责在程序执行主编译之前对源文件进行预处理。

预处理器在代码编译阶段自动执行==#==开头的编译指令。

例如：在执行<code>#include <iostream></code>  代码的时候

原始文件并没有被修改，将iostream文件中的内容随同源代码一起发给编译器，编译的下一个阶段则使用该文件。

***

#### 2.1.4 头文件名

头文件,类似于<code>iostream</code>这样的文件也叫做包含文件，因为它们被包含在其他文件之中。

C++新式头文件约定，不使用任何扩展名。（以前旧版的使用是iostream.h）

---

#### 2.1.5 命名空间

在我们使用cout或者cin的时候，其实是使用了命名空间std中的标准组件。

> 当我们在编写大型程序的时候，可能会遇到两个都已经封装好了的代码，这两个代码中都包含了一个叫<code>ruan()</code>的函数，这个时候，厂商只需要将其产品封装在自己的一个命名空间的单元中，这样就可以用命名空间来指出想要使用哪个厂商的产品。

其实，我们使用<code>using namespace std;</code> 是一种偷懒的方法，最好的方法是  <code>std::cout<<</code> 以及 <code>std::cin</code> 或者<code>std::endl</code> 等等，但是这样又很麻烦，没必要每一次使用std命名空间时都要加上<code>std::</code> 字样的前缀，于是有一种省事的方法，那就是用什么就引入什么:

```c++
using std::cout;
using std::endl;
using std::cin; 
```

当然学习阶段我们用不着考虑这么麻烦，在遇到大型开发之前，我们都习惯使用 <code>using namespace std;</code> 这种简单而省事的方法。

---

#### 2.1.6 使用cout进行C++输出

输出是一个流，而cout对象表示这一种流，其具体属性是定义在iostream文件之中的，它的对象属性包含一个被重载了的插入运算符(<<)。而<<的功能是将它右侧的信息插入到输出流(cout)之中。

> 1.控制符endl

endl在C++中表示的概念是重启一行，输入流读到endl的时候会将光标移动到下一行（光标默认是停留在前一个字符的末尾）。

> 2.换行符\n

与endl不同，可以包含在" "的内容之中。

---

#### 2.1.7 C++源代码的格式化

在C++中，<code>;</code> 的作用是标识一个语句的结尾而不是回车，所有可以自由将一条语句放到几行上，但是不建议这样做。

<table><tr><td bgcolor=orange>在C++中，回车和空白可以互换，例如以下：</td></tr></table>

```c++
int main(){
    
}
```

<table><tr><td bgcolor=orange>可以这样写:</td></tr></table>

```c++
int
    main(){
    
}
```

但是，在C++中，还是大家约定：

* 每条语句占一行
* 每个函数都有一个开始花括号和一个结束花括号，这两个花括号各占一行。
* 函数中的语句都相当于花括号进行缩进
* 与函数名称相关的花括号周围没有空白

***

### 2.2 C++语句

#### 2.2.1 声明语句和变量

声明通常指出了要存储的数据类型以及包含了对存储在这里的数据所使用名称。在程序中的声明语句叫做定义声明，简称为定义，这将导致编译器为变量分配内存空间。

> 声明语句结构：

<code>int ruan;</code>

数据类型   变量名     分号结尾

---

#### 2.2.2 赋值语句

赋值语句负责将值赋给存储单元，通常形式：

<code>ruan = 25;</code>

表示将整数25赋给变量名为ruan的存储单元。

C++运行连续赋值，例如：

```c++
ruan = mou = wang =25;
```

还允许算术赋值，例如

```c++
ruan = mou -1;
```

将算术式<code>mou - 1</code> 的结构计算出来并将值赋给内存单元ruan。

***

#### 2.2.3 cout的新花样

传统的C语言的打印函数<code>printf()</code> ，必须使用特殊代码(%s和%d)来区分打印的是字符串还是整数，C++的cout要聪明得多。例如：

在执行 <code>cout<< 25 </code> 这条语句的时候，并不需要像C一样先去标识这个 25 是整数类型25 还是字符串 2 5 ，而是直接将其当作字符串打印。

> 完整解读

```c++
cout<< ruan ;
```

cout 先将ruan转换为其所存储的整数25，再将整数25转换为合适的输出字符 2 和 5，然后插入输出流中。

**总结**：cout相较于printf能够识别类型并进行调整输出。

***

### 2.3 其他C++语句

#### 2.3.1 使用cin

cin使用>>运算符从输入流中抽取字符，iostream文件将cin定义为表示这种流的对象,同样cin也会对读到的类型进行智能转化。

---

#### 2.3.2 使用cout进行拼接

1. cout语句的输出紧跟在前一条cout语句的输出后面，即使两条cout语句之间有其他语句也是这样。 
2. cout语句能够通过类似于这样  <code>cout << ruan's age is << 25  <<endl;</code> 进行对不同类型的显示拼接。

---

#### 2.3.3  类简介

**类描述了一种数据类型的全部属性（包括可使用它执行的操作）.**

类是C++面向对象编程(OOP)的核心之一。

类可以又程序员自身去定义，也可以来自于函数库，C++自身定义了例如ostream类和istream类等等。

***

### 2.4 函数

函数分为有返回值的和没有返回值的函数，它们往往用于创建C++程序的模块。

#### 2.4.1 使用有返回值的函数

示例代码 ：              <code>   X   =   sqrt(6.25);    </code>

解释： 表达式将调用<code> sqrt() </code> 函数，这个过程叫做==函数调用==，然后被调用的函数叫做==被调用函数==，整个这个式子叫做==调用函数==。

6.25 作为==参数==传递给<code> sqrt() </code>函数，被调用函数通过传入的参数计算出结果0.25 并将结果值赋给调用函数，这个发送回去的值0.25就叫做==返回值==。

在某个函数之前存在一个指出函数所涉及什么类型的函数，叫做函数原型.

例如这个例子中的这个<code> sqrt() </code>函数 的函数原型为 <code> double  sqrt(double); </code>

**C++应当为程序中所使用的每一个元素提供原型。**在程序中又两种方式来提供原型：

1. 在源代码中输入原型的代码。
2. 包含 包含整个函数原型的头文件(例如本例的sqrt()对应的cmath头文件)。 （老式编译器要用<code> #include<math.h> </code>而不是<code> #include<>cmath</code> ）

C++还允许使用创建的变量对其进行赋值，这个过程被称为初始化（initialization），例如：

```c++
double ruan;
cin>>ruan;
double mou = sqrt(ruan);
```

***

#### 2.4.2 函数变体

此外，还有很多中函数：

> 1. 参数不止一个，例如<code> pow() </code>接受两个参数，用于计算第一个为底，第二个为幂的值。
> 2. 不接受任何参数，例如<code> rand(void) </code> 生成随机数不需要参数。
> 3. 没有返回值，例如我们自定义一个打印的函数。  因为它没有返回值，所以不能将该函数该调用放在赋值语句或者其他表达式之中。

在C++中，函数调用就必须使用括号，无论是否需要参数。

在C++中，又返回值的一般称为函数，没有返回值的一般称为过程。

***

#### 2.4.3 用户定义的函数

1. **函数格式** 

用户可以自定义函数，通常的做法是将自定义函数的原型放在main函数前面，这样main函数就知道有这么一个函数原型，然后再将这个函数原型的实现代码放在main函数的后面一般。示例：

```c++
#include<iostream>
using namespace std;
void ruan(int);            //这里放函数的原型，它的具体实现代码在main函数的后面
int main(){
    ruan(3);                //这里调用了这个函数
    return 0;
}
void ruan(int n){               
    cout<<ruan's number is <<n<<endl;
}
```

<table><tr><td bgcolor=orange >     C++不允许将一个函数定义嵌套在另一个函数定义中。</td></tr></table>

2. **函数头**

上面的例子表示，ruan这个函数接收一个int类型的参数，并且返回类型为空(void).

以mian函数为示例解读：

```c++
int main(){
    return 0;
}
```

> 开头的int表示main函数保护将返回一个整数值，空括号表示main函数没有参数。

只要是有返回值的函数保护，都必须使用一个return来提供返回值。

在操作系统中约定main函数返回0的时候则表示程序运行成功！

***

#### 2.4.4 用户定义的有返回值的函数

函数设计的标准：

> 1. 有函数头和函数体
> 2. 接受一个参数
> 3. 返回一个值
> 4. 需要一个原型

***

#### 2.4.5 在多函数程序中使用using编译指令

* 将<code> using namespace std; </code> 放在函数定义之前，让文件中所有的函数都能够使用命名空间std中的所有元素。
* 将<code> using namespace std; </code>放在特定的函数定义中，让该函数能够使用命名空间std中的所有元素。



* 在特定的函数中使用类似<code> using std::cout; </code>这样的编译指令，而不是<code> using namespace std; </code>，让该函数能够使用特定的元素，比如cout
* 完全不使用编译指令using，而在需要使用命名空间std中的元素时，使用前缀std::

***

## 第三章：处理数据

C++排除用户自己定义数据类型外，还包含了两种内置的数据类型：**基本类型**和***复合类型**

本章介绍基本类型，即整数和浮点数

### 3.1 简单变量

数据在计算机中的基本属性：

* 信息存储在哪里
* 要储存什么值
* 存储何种类型的信息

#### 3.1.1 变量名

命名规则：

* 字符集：C++允许使用字母、数字和下划线来命名变量。变量名称必须以字母或下划线开头，不能以数字开头。
* 大小写敏感：C++区分大小写，因此"myVar"和"myvar"被视为不同的变量。
* 标识符长度：标准C++要求变量名的长度至少为一个字符，并且不能超过特定编译器的限制（通常为255个字符）。
* 保留字：不能使用C++中的保留字（例如if、for、int等）作为变量名。
* 合法命名示例：合法的变量名称示例包括"age"、“myVariable”、"my_var"等。
* 不推荐使用的命名方式：虽然在语法上是合法的，但应避免使用单个字母或无意义的变量名，因为这样会导致代码难以理解和维护。
* 规范约定：尽可能选择有意义且描述准确的变量名，以便让其他人能够轻松理解代码的含义。
* 命名风格：常见的命名风格包括驼峰命名法和下划线命名法。在团队合作中，应遵循统一的命名风格。
* 清晰明了：使用具有描述性的变量名可以提高代码的可读性，使其更易于理解和维护。

***

#### 3.1.2 整型

**整型**就是没有小数部分的数字，其中又划分为==有符号类型==和==无符号类型==.

**整数类型（Integral Types）**

- 

- | 类型                 | 描述                 | 典型大小    | 最小值                     | 最大值                     |
  | -------------------- | -------------------- | ----------- | -------------------------- | -------------------------- |
  | `short`              | 短整型               | 2 字节      | -32,768                    | 32,767                     |
  | `unsigned short`     | 无符号短整型         | 2 字节      | 0                          | 65,535                     |
  | `int`                | 整型                 | 4 字节      | -2,147,483,648             | 2,147,483,647              |
  | `unsigned int`       | 无符号整型           | 4 字节      | 0                          | 4,294,967,295              |
  | `long`               | 长整型               | 4 或 8 字节 | -2,147,483,648 (4 字节)    | 2,147,483,647 (4 字节)     |
  | `unsigned long`      | 无符号长整型         | 4 或 8 字节 | 0                          | 4,294,967,295 (4 字节)     |
  | `long long`          | 长长整型             | 8 字节      | -9,223,372,036,854,775,808 | 9,223,372,036,854,775,807  |
  | `unsigned long long` | 无符号长长整型       | 8 字节      | 0                          | 18,446,744,073,709,551,615 |
  | `char`               | 字符型（通常为整型） | 1 字节      | -128                       | 127                        |
  | `unsigned char`      | 无符号字符型         | 1 字节      | 0                          | 255                        |

- 

  ***

#### 3.1.3 整型 short、int、long和long long

> 1. **运算符sizeof和头文件limits**

sizeof运算符返回类型或者变量的长度

` <climits> ` 头文件（C++ 中也可以用 `<limits.h>`）定义了各种与数据类型相关的符号常量，这些常量表示不同数据类型的取值范围。这些符号常量包括整数类型的最小值和最大值，以及字符类型的最小值和最大值。下面列举了 `<climits>` 中的一些常用符号常量：

整数类型的符号常量

- **`CHAR_BIT`**：表示一个字节中的位数，通常为 8。
- **`CHAR_MIN`**：表示 `char` 类型的最小值。
- **`CHAR_MAX`**：表示 `char` 类型的最大值。
- **`SCHAR_MIN`**：表示 `signed char` 类型的最小值。
- **`SCHAR_MAX`**：表示 `signed char` 类型的最大值。
- **`UCHAR_MAX`**：表示 `unsigned char` 类型的最大值。
- **`SHRT_MIN`**：表示 `short int` 类型的最小值。
- **`SHRT_MAX`**：表示 `short int` 类型的最大值。
- **`USHRT_MAX`**：表示 `unsigned short int` 类型的最大值。
- **`INT_MIN`**：表示 `int` 类型的最小值。
- **`INT_MAX`**：表示 `int` 类型的最大值。
- **`UINT_MAX`**：表示 `unsigned int` 类型的最大值。
- **`LONG_MIN`**：表示 `long int` 类型的最小值。
- **`LONG_MAX`**：表示 `long int` 类型的最大值。
- **`ULONG_MAX`**：表示 `unsigned long int` 类型的最大值。
- **`LLONG_MIN`**：表示 `long long int` 类型的最小值。
- **`LLONG_MAX`**：表示 `long long int` 类型的最大值。
- **`ULLONG_MAX`**：表示 `unsigned long long int` 类型的最大值。

> 2. **使用变量之前，务必要对变量进行初始化**

现在的初始化方式（到C++11）

```c++
int main() {
    // 传统的初始化方式
    int a = 5;               // 拷贝初始化
    int b(6);                // 直接初始化
    string str = "Hello"; // 拷贝初始化
    string str2("World"); // 直接初始化

    // 列表初始化
    int c = {7};             // 拷贝列表初始化
    int d{8};                // 直接列表初始化
    int e{};                 // 值初始化（初始化为0）
    string str3{};      // 值初始化（初始化为空字符串）

    // 使用 auto 关键字
    auto f = 9;              // 类型是 int
    auto str4 = "Auto";      // 类型是 const char*
    auto vec = {1, 2, 3};    // 类型是 std::initializer_list<int>

    // 使用智能指针
    std::unique_ptr<int> ptr1 = std::make_unique<int>(10);
    auto ptr2 = std::make_unique<int>(20); // 自动类型推导
    std::shared_ptr<int> ptr3 = std::make_shared<int>(30);
    auto ptr4 = std::make_shared<int>(40); // 自动类型推导
}
```

<table><tr><td bgcolor = orange>        为了提高程序的可移植性，建议使用long long 数据类型   </td></tr></table>

***

#### 3.1.6 整型字面值

C++有三种表示整型的方式：8进制（老师UNIX版本）、10进制、16进制（黑客常用），在默认情况下，cout以十进制形式显示整数。不管怎么显示，整型在计算机中是以2进制存储的（0 和1）。

iostream提供了三个控制符用于控制输出

dec

> decimal      adj.n.    十进制的

hex

> hexadecimal   adj.n     十六进制的

oct

> octal   adj.n.   八进制的

```c++
cout<<dec;                               //改变输出流，修改整数输出方式为：十进制。
cout<<hex;                               //修改为：十六进制的
cout<<oct;                               //修改为： 八进制
```

以上三条语句都不会在屏幕上显示任何内容，单纯更改cout显示整数的方式。

---

#### 3.1.7 C++如何确定常量的类型

==第一步：==观察数字的后缀，例如 2500L （或者小写），表示2500数字存储为long类型，同样还有很多后缀类型。

==第二步：==考察数字长度，对于不带后缀的十进制整数，将使用下面几种类型中能够存储该数的最小类型来表示。例如：在int为16位、long长度为32位的计算机系统上，20000记为int类型，40000记为long类型，3000000000记为longlong数据类型。

此外十六进制一般都是被记为unsigned int ，因为十六进制通常被用来表示内存地址，是没有符号的。

最后C++默认将整型常量存储为int 类型。

---

#### 3.1.8 char 类型：字符和小整数

char类型是专为存储字符(字母和数字)而设计的

一般情况下，C++实现都是使用其主机系统所使用的编码，一般是ASCII码。

C++中，使用cin和cout对字符char类型进行了自动转换操作，示例：

```c++
int main(){
    char ruan;
    cout<<"请输入一个字符"<<endl;
    cin>> ruan;
    cout<<"您输入的字符是"<<ruan<<"字符"<<endl;
}
```

输出：

```cmd
C:\Users>请输入一个字符
M
C:\Users>您输入的字符是M字符
```

解释：**输入时，**cin将键盘输入的M转换为77，并且存储在ruan的那一块内存中，**输出时，**cout将所存储的77转换为字符M。

代码中的'M'的对应的ASCII码值为77，其实也是一个整数，所以能够进行整数的运算。

> 这里补充介绍了成员函数cout.put()    主要用于早期版本C++的cout不能正常处理字符

这个函数用于输出一个字符。例如<code> cout.put("!"); </code>    对应输出  <code> ! </code>   ，提供了另一种显示字符的方法，代替了cout

 

此外，还有一些字符是不方便表示的，不能直接通过敲击键盘输入到程序中的，C++提供了一种特殊的方法———转义序列，如下表：

| 字符名称       | ASCII 编号 | 转义序列 | 十进制 ASCII 码 | 十六进制 ASCII 码 |
| -------------- | ---------- | -------- | --------------- | ----------------- |
| 换行符         | LF         | `\n`     | 10              | 0x0A              |
| 回车符         | CR         | `\r`     | 13              | 0x0D              |
| 水平制表符     | HT         | `\t`     | 9               | 0x09              |
| 垂直制表符     | VT         | `\v`     | 11              | 0x0B              |
| 退格符         | BS         | `\b`     | 8               | 0x08              |
| 换页符         | FF         | `\f`     | 12              | 0x0C              |
| 警告（响铃）符 | BEL        | `\a`     | 7               | 0x07              |
| 反斜杠         |            | `\\`     | 92              | 0x5C              |
| 单引号         |            | `\'`     | 39              | 0x27              |
| 双引号         |            | `\"`     | 34              | 0x22              |
| 问号           |            | `\?`     | 63              | 0x3F              |
| 空字符         | NUL        | `\0`     | 0               | 0x00              |

> ==补充：==

1. 现在，C++逐渐支持通用字符集Unicode，包括了大量字符，ASCII码只是Unicode的一个子集。
2. 在某些硬件属性的要求下，char虽然在默认情况下没有符号，但是实际上char分为了signed char 和unsigned char。
3. 当遇到某些字符无法处理时，处理使用通用字符集，还可以使用wcin和wcout来处理wchar_t(宽字符类型流)。
4. 在此基础上仍然还有一些字符无法处理，C++11支持了char16_t和char32_t。

***

####3.1.9 bool类型

布尔类型，任何非零值都可以转换为true，而0转换为false

***

### 3.2 const 限定符

const可以用于将修改的量更改为**只读**。

***

### 3.3 浮点数

- **`float`**：单精度浮点型，通常占 4 个字节。
- **`double`**：双精度浮点型，通常占 8 个字节。
- **`long double`**：扩展精度浮点型，通常占 8、12 或 16 个字节，具体取决于实现。

***

#### 3.3.1 书写浮点数

*  标准小数点表示法，如                      `3.14 `         常规                                   适用于精确表示某个小数
* E表示法，如                                       `3.14E5`     表示3.14乘以100,000       更适用于表示非常大或者非常小的数

（这个3.14E5可以理解为3.14小数点再往右移动5位）

***

#### 3.3.2 浮点类型

| 类型          | 描述                       | 典型大小         | 有效位数（精度）                     | 范围                               |
| ------------- | -------------------------- | ---------------- | ------------------------------------ | ---------------------------------- |
| `float`       | 单精度浮点数               | 4 字节           | 约 7 位十进制数字                    | 1.2E-38 到 3.4E+38                 |
| `double`      | 双精度浮点数               | 8 字节           | 约 15 位十进制数字                   | 2.3E-308 到 1.7E+308               |
| `long double` | 扩展精度浮点数（平台相关） | 8 字节或 16 字节 | 通常至少 15 位十进制数字（通常更高） | 1.2E-4932 到 1.1E+4932（平台相关） |

>  通常cout在输出的时候，会删除结尾的0.

***

#### 3.3.3 浮点常量

通常情况下，如果希望是float类型，就使用F后缀（都是无所谓大小写），如果希望是long double 类型，就使用L后缀

***

#### 3.3.4 浮点数的优缺点

* 优点：表示了整数之间的值，增大了计算机可以表达数字的范围
* 缺点，浮点数的运行速度不行，而且运算时可能会丢失精度。

***

### 3.4 C++算术运算符

| 运算符 | 描述              | 示例           | 结果                 |
| ------ | ----------------- | -------------- | -------------------- |
| `+`    | 加法              | `a + b`        | 将 `a` 和 `b` 相加   |
| `-`    | 减法              | `a - b`        | 将 `b` 从 `a` 中减去 |
| `*`    | 乘法              | `a * b`        | 将 `a` 和 `b` 相乘   |
| `/`    | 除法              | `a / b`        | 将 `a` 除以 `b`      |
| `%`    | 取模（取余）      | `a % b`        | `a` 除以 `b` 的余数  |
| `++`   | 自增（前缀/后缀） | `++a` 或 `a++` | 将 `a` 增加 1        |
| `--`   | 自减（前缀/后缀） | `--a` 或 `a--` | 将 `a` 减少 1        |
| `-`    | 负号（取反）      | `-a`           | `a` 的负值           |

***

#### 3.4.1 运算符的优先级和结合性

仅当两个两个运算符被用于同一操作数时，优先级和结合规则生效。（和我们自然状态下的优先级相同）

***

#### 3.4.2 除法分支

除法操作符的最终行为取决于操作数的类型，如果操作数都是整数，那么会执行整数除法（丢掉后面的小数精度，使最后结果是一个整数）。

C++在对不同类型的数进行计算时，喜欢将它们转换为同一类型。

***

#### 3.4.3 求模运算符

***

#### 3.4.4 类型转换

##### 3.4.4.1 初始化和赋值类型的转换。

C++经常会遇到类型转换的时候：

* 将一种算术类型赋值给另一种算术类型，C++对值进行类型转换。
* 表达式中包含不同中类型时，C++先转换为同一种再执行运算。
* 将参数传递给函数时，C++对值进行转换 。

C++通常会对数值进行类型转换，类型转换会遇到的问题：

1. <u>较大</u> 浮点数 转 <u>较小</u> 浮点数，会丢失精度。
2. 浮点数转为整数，直接小数部分全丢。
3. <u>较大</u> 整型 转 <u>较小</u> 整型,通常只复制最右边的字节。

##### 3.4.4.2以{ }方式初始化时进行的转换(C++11)

C++将使用大括号进行初始化的操作称为列表初始化，这种初始化对类型转换的要求更为严格。

1. 不允许转换的类型 “**缩窄**”                       `通俗说就是不允许float转int，转换条件是编译器要知道目标变量能够正确地存储赋给它的值。`
2. 不允许使用变量初始化                           `假如x= 50; char ruan ={x};任然是不被允许的，因为列表初始化不允许被变量初始化。`

##### 3.4.4.3 表达式中的转换

当同一个表达式中包含两种不同的变量类型的时候，C++会使用类型转换，通常情况下是会自动转换为int类型。（因为在计算机中，使用整型能够提高计算机的运行速度）

当不同类型进行算术运算时，C++一般选择将较小的类型转换为较大的类型来保留计算的**精度**。（较大的类型具有更高的优先级）

##### 3.4.4 传递参数时的转换

传递参数的转换通常由C++函数原型控制（所以是可以修改的，但是不建议），一般情况下对float提升为double精度，其他的都提升为整型。

##### 3.4.5 强制类型转换（建议网上视频巩固）

每种强制类型转换在 C++ 中都有其特定的用途和适用场景：

- **C 风格转换**：不推荐使用，因为它不安全且不明确。
- **`static_cast`**：用于良性转换，编译时进行。
- **`dynamic_cast`**：用于类层次结构中的安全向下转换，运行时进行。
- **`const_cast`**：用于去除或增加常量性。
- **`reinterpret_cast`**：用于重新解释位模式，需小心使用。

> **C 风格转换**：

语法：`目标类型 变量名 = (目标类型) 原变量;`

> **`static_cast`**:

语法：`目标类型 变量名 = static_cast<目标类型>(原变量);`

> **`dynamic_cast`**:

语法：`派生类指针或引用 = dynamic_cast<派生类类型>(基类指针或引用);`

> **`const_cast`**:

语法：`非 const 类型指针或引用 = const_cast<非 const 类型>(const 类型指针或引用);`

> **`reinterpret_cast`**:

语法：`目标类型指针或引用 = reinterpret_cast<目标类型>(原类型指针或引用);`

***

#### 3.4.5 C++中的auto声明

C++11新增了一种能够通过初始值的类型推断变量类型的C语言关键字。

```c++
auto n = 100;          //n就会被推断成是一个int
```

当使用简单类型时，不建议使用auto（书上原话说会让你误入歧途），auto往往是处理复杂类型时，如标准模板库（STL）中的类型时，auto的优势才体现出来。

***

##第四章： 复合类型

C++ 中的复合类型（compound types）是由基本类型（如 `int`、`char` 等）构成的更复杂的数据类型。复合类型包括指针、引用、数组、枚举、结构体和类。

### 4.1 数组

数组是 C++ 中的一种基本数据结构，用于存储一组相同类型的元素。数组在内存中占用连续的空间，数组的元素通过索引进行访问。

数组的声明方式：    `数组元素类型 数组名[数组长度];`

数组长度不能是变量，必须是整型常数或者const修饰的值。

数组通过下标（或索引）访问具体的值。

#### 4.1.2 数组的初始化规则

C++对于数组的初始化有几条规则：

1. 只有在定义数组的时候才能使用初始化，之后就不能使用了，也不能将一个数组赋给另一个数组。
2. 如果只对数组的一部分进行初始化，则编译器会把其他元素设置为0。

***

#### 4.1.3 C++数组初始化方法

前面说过，C++11将使用大括号的初始方法（列表初始化），来作为一种通用的初始化方法，可以适用于所有的类型。

| 初始化方式                 | 语法示例                                    | 描述                                                         |
| -------------------------- | ------------------------------------------- | ------------------------------------------------------------ |
| 默认初始化                 | `int arr[5];`                               | 数组元素未初始化，元素值未定义。                             |
| 列表初始化（显式大小）     | `int arr[5] = {1, 2, 3};`                   | 指定数组大小，并用列表中的值初始化元素，未列出的元素初始化为零。 |
| 列表初始化（自动大小）     | `int arr[] = {1, 2, 3, 4, 5};`              | 根据列表元素的数量自动推断数组大小。                         |
| 列表初始化（全部为零）     | `int arr[5] = {0};`                         | 初始化所有元素为零。                                         |
| 列表初始化（部分为零）     | `int arr[5] = {1};`                         | 仅初始化第一个元素为 1，其他元素为零。                       |
| 列表初始化（无值）         | `int arr[5] = {};`                          | 初始化所有元素为零。                                         |
| 值初始化                   | `int* arr = new int[5]();`                  | 动态分配数组并将所有元素初始化为零。                         |
| 动态数组初始化（默认）     | `int* arr = new int[5];`                    | 动态分配数组，元素未初始化。                                 |
| 动态数组初始化（显式大小） | `int* arr = new int[5]{1, 2, 3};`           | 动态分配数组并用列表中的值初始化，未列出的元素初始化为零。   |
| 动态数组初始化（部分为零） | `int* arr = new int[5]{1};`                 | 动态分配数组，仅初始化第一个元素为 1，其他元素为零。         |
| 动态数组初始化（全部为零） | `int* arr = new int[5]{};`                  | 动态分配数组并将所有元素初始化为零。                         |
| 标准库容器 `std::array`    | `std::array<int, 5> arr = {1, 2, 3, 4, 5};` | 使用 `std::array` 初始化，并指定大小和初始值。               |

C++的标准模板库（STL）提供了一种数组的替代品——模板类 Vector，而C++11新增了模板类array，比传统的数组更加方便、灵活。

***

### 4.2 字符串

字符串是存储在内存中的连续字节中的一系列字符。C++中包含了两种：

1. 来自于C语言的常常被称作**C风格字符串(C-style string)**
2. 基于string类库的方法

C风格字符串具有一种特殊的性质：以空字符(null character)结尾， 空字符被写作\0，其ASCII码为0，用来标记字符串的结尾。

> 为什么需要 `'\0'`

1. **字符串长度**：没有 `'\0'`，我们无法确定字符串的长度。例如，标准库函数 `strlen` 通过查找 `'\0'` 来确定字符串的长度。
2. **字符串处理**：许多字符串处理函数（如 `strcpy`、`strcat` 等）都依赖 `'\0'` 来确定字符串的结束。

```c++
char ruan[5] = {'a','b','c','d','e'};    //错误的，并不是字符串，而是由字符组成的数组
char mou[5] = {'a','b','c','\0'};        //正确的，是字符串
```

以上的字符串的正确表达方式过于麻烦(由大量' '，并且要记住末尾必须是\0)，有一种更好的方法：

```c++
char ruan[11]="Hello, Ruan"                      //别忘了\0 也占一位
char mou[]="i am mrs Mou"                        //让计算机统计长度
```

用括号括起的字符串隐式地包括结尾的空字符，因此不需要显式地包括它（就是没必要自己手动加上'\0'），一般C++通过键盘输入，将字符串读入char数组中时，会自动加上结尾的空字符，所以<u>在确定存储字符串所需的最短数组时，别忘了将结尾的空字符计算在内。</u>

<table><tr><td bgcolor=orange>单引号'a'和双引号"a"的区别，也就是字符与字符串的区别，字符串包含了两个字符：'a'和'\0'</td></tr></table>

***

#### 4.2.1 拼接字符串常量

字符串不会被空格、制表符、换行符打断，它会自动拼接为一个。

***

#### 4.2.2 在数组中使用字符串

***

#### 4.2.3 字符串输入

一般使用关键字cin ，而cin使用空白（**空格、制表符、换行符**）来确定字符串的结束位置，读取完成后自动在末尾添加空字符。

`例如：              ruan          (大约就是一个单词)  `

请看下面这一段程序，它有一个很有趣的点：

```c++
int main() {
	string name;
	string food;
	cout << "请输入姓名：" << endl;
	cin >> name;
	cout << "请输入食物" << endl;
	cin >> food;
	cout << name << "在吃" << food << endl;
}
```

![](.\asset\程序截图0529.png)

我输入的是<code>ruan orange</code>  ，因为中间存在空格，所以cin只是将ruan读到，并且存储在**name**数组中，然后orange依然在输入队列中。然后当程序遇到第二个输入 <code> cin>>food </code>的时候，cin直接读到输入队列中还存放着有字符串orange ，所以无需输入，而是直接将读到的字符串orange 存储在**food**数组中。

***

#### 4.2.4  每次读取一行字符串输入

就上面的输入方式（使用cin），我们无法读取超过一个单词的输入，为此，istream包含了一些面向行的类成员的函数：<code> getline() </code>和<code> get() </code>，这两个函数都是读到一行输入，直到遇到==换行符==。

> 1. 面向行的输入： <code> getline() </code>

cin.getline() 提供两个参数，（存储输入行的数组的名称  ,    要读取的字符数  ），例如：

```c++
cin.getline(name, 20);                  //将姓名存储到一个包含20个元素的name数组中。
```

> 2. 面向行一个字符一个字符的输入: <code> get() </code>

cin.get()和cin.getline 接受一样的参数。

但是二者的**区别**是：  getline()  在读到==换行符==之后，就会自动丢弃换行符。

​                                而get（）在读到==换行符==之后，并不会丢弃==换行符==，而是保留在输入队列中，假如我们连续两次两次调用get()，例如：

<code>cin.get(name,20);</code>

<code>cin.get(age,20);</code>

第二行就会一上来就读到第一行屁股后面的换行符，它判断为已经到达行尾，而没有发现任何可以读取的内容。**cin.get()需要借助帮助才能跨越换行符。**

一般想用get来输入的话，是这样：                                     使用一个没有参数的get()来处理换行符

```c++
cin.get(name,20);                  //第一行正常输入
cin.get();                         //第二行用来处理换行符，这一行都不会显示
cin.get(age,20);                   //第三行就可以正常输入了
```

另一种写法是:

```c++
cin.get(name,20).get();           //这样等同于在第一行输入的语句后面添加了一个cin.get();
```

<font color="red">补充：</font>这里之所以可以这样做：是因为cin.get(Name,ArraySize)本身也会返回一个cin对象，这个cin对象看到屁股后面跟着一个 get()，又会自动调用后面的cin.get()。这个法则同样适用于cin.getline:

```c++
cin.getline(Name1,ArraySize).getline(Name2,ArraySize);       //这句话等同于连续输入两行getline并保存在Name1和Name2中。
```

<u>使用 get() 比 getline() 将会更加细致，但是也增加了麻烦。</u>

***

#### 4.2.5 小结

- `cin >>` 会自动跳过输入中的空白字符，包括空格、制表符和换行符。
- `cin.get()` 会读取并保留空白字符，包括换行符。
- `cin.getline()` 会读取整行输入，并丢弃换行符。

***

###string 类简介

C++98标准在C++中添加了string类，要使用的话，需要包含头文件<code> <string> </code>

相对于char数组来说，char数组只是存储一个字符串的存储单元，而string 类变量是一个表示字符串的实体。

#### 4.3.1 C++字符串初始化

C++中的string类也支持列表初始化:

```c++
string ruan = {" the name of someone"};        //相似于  char ruan[] = {" the name of someone"};
string mou {" the name of a lady"};            //相似于  char mou[] {" the name of a lady"};
```

***

#### 4.3.2 赋值、拼接和附加

##### 1. 赋值

数组不能将一个数组赋给另一个数组，但是可以将一个string 对象赋给另一个string对象。

##### 2.拼接和附加

string对香港允许使用+运算符将两个string对象拼接起来。

string 对象允许使用+= 运算符将字符串追加到string字符串的末尾。

***

#### 4.3.3 string类的其它操作

