###电子书网址

作者：Ruan 

https://www.epubit.com/bookDetails?id=UB7209840d845c9&recommenderCode=2828799y

参考文献：

https://blog.csdn.net/m0_74195174/article/details/136323032

14783**词**当前       

<font size = 2 color=red></font> 

<table><tr><td bgcolor = orange> </td></tr></table>

## 第二章：开始学习C++

###2.1 进入C++

#### 2.1.1 main函数

**c++函数结构**

```c++
#include <iostream>
using namespace std;             //函数头部分，是函数与程序其他部分的一个接口


int main(){
                                 //函数体部分，指出了这个函数要做什么事情
    
    
    
    return 0;                     //返回语句  ，表示该函数结束
}
```

在运行c++程序的时候，通常是从main函数开始的，main函数被启动代码调用，而启动代码是由编译器添加到程序中的，是程序与操作系统之间的桥梁。

所有c++程序必须包含一个main()

> 这里插入一下void和空白的用法

在c++中，void就是空白，空白就是void

***

#### 2.1.2 C++注释

常见的注释方法：  <code>//</code>

C风格注释: <code>* 包含需要注释掉的内容 *</code>    优点：可以跨越多行

***

#### 2.1.3 C++预处理器和iostream文件

预处理器负责在程序执行主编译之前对源文件进行预处理。

预处理器在代码编译阶段自动执行==#==开头的编译指令。

例如：在执行<code>#include <iostream></code>  代码的时候

原始文件并没有被修改，将iostream文件中的内容随同源代码一起发给编译器，编译的下一个阶段则使用该文件。

***

#### 2.1.4 头文件名

头文件,类似于<code>iostream</code>这样的文件也叫做包含文件，因为它们被包含在其他文件之中。

C++新式头文件约定，不使用任何扩展名。（以前旧版的使用是iostream.h）

---

#### 2.1.5 命名空间

在我们使用cout或者cin的时候，其实是使用了命名空间std中的标准组件。

> 当我们在编写大型程序的时候，可能会遇到两个都已经封装好了的代码，这两个代码中都包含了一个叫<code>ruan()</code>的函数，这个时候，厂商只需要将其产品封装在自己的一个命名空间的单元中，这样就可以用命名空间来指出想要使用哪个厂商的产品。

其实，我们使用<code>using namespace std;</code> 是一种偷懒的方法，最好的方法是  <code>std::cout<<</code> 以及 <code>std::cin</code> 或者<code>std::endl</code> 等等，但是这样又很麻烦，没必要每一次使用std命名空间时都要加上<code>std::</code> 字样的前缀，于是有一种省事的方法，那就是用什么就引入什么:

```c++
using std::cout;
using std::endl;
using std::cin; 
```

当然学习阶段我们用不着考虑这么麻烦，在遇到大型开发之前，我们都习惯使用 <code>using namespace std;</code> 这种简单而省事的方法。

---

#### 2.1.6 使用cout进行C++输出

输出是一个流，而cout对象表示这一种流，其具体属性是定义在iostream文件之中的，它的对象属性包含一个被重载了的插入运算符(<<)。而<<的功能是将它右侧的信息插入到输出流(cout)之中。

> 1.控制符endl

endl在C++中表示的概念是重启一行，输入流读到endl的时候会将光标移动到下一行（光标默认是停留在前一个字符的末尾）。

> 2.换行符\n

与endl不同，可以包含在" "的内容之中。

---

#### 2.1.7 C++源代码的格式化

在C++中，<code>;</code> 的作用是标识一个语句的结尾而不是回车，所有可以自由将一条语句放到几行上，但是不建议这样做。

<table><tr><td bgcolor=orange>在C++中，回车和空白可以互换，例如以下：</td></tr></table>

```c++
int main(){
    
}
```

<table><tr><td bgcolor=orange>可以这样写:</td></tr></table>

```c++
int
    main(){
    
}
```

但是，在C++中，还是大家约定：

* 每条语句占一行
* 每个函数都有一个开始花括号和一个结束花括号，这两个花括号各占一行。
* 函数中的语句都相当于花括号进行缩进
* 与函数名称相关的花括号周围没有空白

***

### 2.2 C++语句

#### 2.2.1 声明语句和变量

声明通常指出了要存储的数据类型以及包含了对存储在这里的数据所使用名称。在程序中的声明语句叫做定义声明，简称为定义，这将导致编译器为变量分配内存空间。

> 声明语句结构：

<code>int ruan;</code>

数据类型   变量名     分号结尾

---

#### 2.2.2 赋值语句

赋值语句负责将值赋给存储单元，通常形式：

<code>ruan = 25;</code>

表示将整数25赋给变量名为ruan的存储单元。

C++运行连续赋值，例如：

```c++
ruan = mou = wang =25;
```

还允许算术赋值，例如

```c++
ruan = mou -1;
```

将算术式<code>mou - 1</code> 的结构计算出来并将值赋给内存单元ruan。

***

#### 2.2.3 cout的新花样

传统的C语言的打印函数<code>printf()</code> ，必须使用特殊代码(%s和%d)来区分打印的是字符串还是整数，C++的cout要聪明得多。例如：

在执行 <code>cout<< 25 </code> 这条语句的时候，并不需要像C一样先去标识这个 25 是整数类型25 还是字符串 2 5 ，而是直接将其当作字符串打印。

> 完整解读

```c++
cout<< ruan ;
```

cout 先将ruan转换为其所存储的整数25，再将整数25转换为合适的输出字符 2 和 5，然后插入输出流中。

**总结**：cout相较于printf能够识别类型并进行调整输出。

***

### 2.3 其他C++语句

#### 2.3.1 使用cin

cin使用>>运算符从输入流中抽取字符，iostream文件将cin定义为表示这种流的对象,同样cin也会对读到的类型进行智能转化。

---

#### 2.3.2 使用cout进行拼接

1. cout语句的输出紧跟在前一条cout语句的输出后面，即使两条cout语句之间有其他语句也是这样。 
2. cout语句能够通过类似于这样  <code>cout << ruan's age is << 25  <<endl;</code> 进行对不同类型的显示拼接。

---

#### 2.3.3  类简介

**类描述了一种数据类型的全部属性（包括可使用它执行的操作）.**

类是C++面向对象编程(OOP)的核心之一。

类可以又程序员自身去定义，也可以来自于函数库，C++自身定义了例如ostream类和istream类等等。

***

### 2.4 函数

函数分为有返回值的和没有返回值的函数，它们往往用于创建C++程序的模块。

#### 2.4.1 使用有返回值的函数

示例代码 ：              <code>   X   =   sqrt(6.25);    </code>

解释： 表达式将调用<code> sqrt() </code> 函数，这个过程叫做==函数调用==，然后被调用的函数叫做==被调用函数==，整个这个式子叫做==调用函数==。

6.25 作为==参数==传递给<code> sqrt() </code>函数，被调用函数通过传入的参数计算出结果0.25 并将结果值赋给调用函数，这个发送回去的值0.25就叫做==返回值==。

在某个函数之前存在一个指出函数所涉及什么类型的函数，叫做函数原型.

例如这个例子中的这个<code> sqrt() </code>函数 的函数原型为 <code> double  sqrt(double); </code>

**C++应当为程序中所使用的每一个元素提供原型。**在程序中又两种方式来提供原型：

1. 在源代码中输入原型的代码。
2. 包含 包含整个函数原型的头文件(例如本例的sqrt()对应的cmath头文件)。 （老式编译器要用<code> #include<math.h> </code>而不是<code> #include<>cmath</code> ）

C++还允许使用创建的变量对其进行赋值，这个过程被称为初始化（initialization），例如：

```c++
double ruan;
cin>>ruan;
double mou = sqrt(ruan);
```

***

#### 2.4.2 函数变体

此外，还有很多中函数：

> 1. 参数不止一个，例如<code> pow() </code>接受两个参数，用于计算第一个为底，第二个为幂的值。
> 2. 不接受任何参数，例如<code> rand(void) </code> 生成随机数不需要参数。
> 3. 没有返回值，例如我们自定义一个打印的函数。  因为它没有返回值，所以不能将该函数该调用放在赋值语句或者其他表达式之中。

在C++中，函数调用就必须使用括号，无论是否需要参数。

在C++中，又返回值的一般称为函数，没有返回值的一般称为过程。

***

#### 2.4.3 用户定义的函数

1. **函数格式** 

用户可以自定义函数，通常的做法是将自定义函数的原型放在main函数前面，这样main函数就知道有这么一个函数原型，然后再将这个函数原型的实现代码放在main函数的后面一般。示例：

```c++
#include<iostream>
using namespace std;
void ruan(int);            //这里放函数的原型，它的具体实现代码在main函数的后面
int main(){
    ruan(3);                //这里调用了这个函数
    return 0;
}
void ruan(int n){               
    cout<<ruan's number is <<n<<endl;
}
```

<table><tr><td bgcolor=orange >     C++不允许将一个函数定义嵌套在另一个函数定义中。</td></tr></table>

2. **函数头**

上面的例子表示，ruan这个函数接收一个int类型的参数，并且返回类型为空(void).

以mian函数为示例解读：

```c++
int main(){
    return 0;
}
```

> 开头的int表示main函数保护将返回一个整数值，空括号表示main函数没有参数。

只要是有返回值的函数保护，都必须使用一个return来提供返回值。

在操作系统中约定main函数返回0的时候则表示程序运行成功！

***

#### 2.4.4 用户定义的有返回值的函数

函数设计的标准：

> 1. 有函数头和函数体
> 2. 接受一个参数
> 3. 返回一个值
> 4. 需要一个原型

***

#### 2.4.5 在多函数程序中使用using编译指令

* 将<code> using namespace std; </code> 放在函数定义之前，让文件中所有的函数都能够使用命名空间std中的所有元素。
* 将<code> using namespace std; </code>放在特定的函数定义中，让该函数能够使用命名空间std中的所有元素。



* 在特定的函数中使用类似<code> using std::cout; </code>这样的编译指令，而不是<code> using namespace std; </code>，让该函数能够使用特定的元素，比如cout
* 完全不使用编译指令using，而在需要使用命名空间std中的元素时，使用前缀std::

***

## 第三章：处理数据

C++排除用户自己定义数据类型外，还包含了两种内置的数据类型：**基本类型**和***复合类型**

本章介绍基本类型，即整数和浮点数

### 3.1 简单变量

数据在计算机中的基本属性：

* 信息存储在哪里
* 要储存什么值
* 存储何种类型的信息

#### 3.1.1 变量名

命名规则：

* 字符集：C++允许使用字母、数字和下划线来命名变量。变量名称必须以字母或下划线开头，不能以数字开头。
* 大小写敏感：C++区分大小写，因此"myVar"和"myvar"被视为不同的变量。
* 标识符长度：标准C++要求变量名的长度至少为一个字符，并且不能超过特定编译器的限制（通常为255个字符）。
* 保留字：不能使用C++中的保留字（例如if、for、int等）作为变量名。
* 合法命名示例：合法的变量名称示例包括"age"、“myVariable”、"my_var"等。
* 不推荐使用的命名方式：虽然在语法上是合法的，但应避免使用单个字母或无意义的变量名，因为这样会导致代码难以理解和维护。
* 规范约定：尽可能选择有意义且描述准确的变量名，以便让其他人能够轻松理解代码的含义。
* 命名风格：常见的命名风格包括驼峰命名法和下划线命名法。在团队合作中，应遵循统一的命名风格。
* 清晰明了：使用具有描述性的变量名可以提高代码的可读性，使其更易于理解和维护。

***

#### 3.1.2 整型

**整型**就是没有小数部分的数字，其中又划分为==有符号类型==和==无符号类型==.

**整数类型（Integral Types）**

- 

- | 类型                 | 描述                 | 典型大小    | 最小值                     | 最大值                     |
  | -------------------- | -------------------- | ----------- | -------------------------- | -------------------------- |
  | `short`              | 短整型               | 2 字节      | -32,768                    | 32,767                     |
  | `unsigned short`     | 无符号短整型         | 2 字节      | 0                          | 65,535                     |
  | `int`                | 整型                 | 4 字节      | -2,147,483,648             | 2,147,483,647              |
  | `unsigned int`       | 无符号整型           | 4 字节      | 0                          | 4,294,967,295              |
  | `long`               | 长整型               | 4 或 8 字节 | -2,147,483,648 (4 字节)    | 2,147,483,647 (4 字节)     |
  | `unsigned long`      | 无符号长整型         | 4 或 8 字节 | 0                          | 4,294,967,295 (4 字节)     |
  | `long long`          | 长长整型             | 8 字节      | -9,223,372,036,854,775,808 | 9,223,372,036,854,775,807  |
  | `unsigned long long` | 无符号长长整型       | 8 字节      | 0                          | 18,446,744,073,709,551,615 |
  | `char`               | 字符型（通常为整型） | 1 字节      | -128                       | 127                        |
  | `unsigned char`      | 无符号字符型         | 1 字节      | 0                          | 255                        |

- 

  ***

#### 3.1.3 整型 short、int、long和long long

> 1. **运算符sizeof和头文件limits**

sizeof运算符返回类型或者变量的长度

` <climits> ` 头文件（C++ 中也可以用 `<limits.h>`）定义了各种与数据类型相关的符号常量，这些常量表示不同数据类型的取值范围。这些符号常量包括整数类型的最小值和最大值，以及字符类型的最小值和最大值。下面列举了 `<climits>` 中的一些常用符号常量：

整数类型的符号常量

- **`CHAR_BIT`**：表示一个字节中的位数，通常为 8。
- **`CHAR_MIN`**：表示 `char` 类型的最小值。
- **`CHAR_MAX`**：表示 `char` 类型的最大值。
- **`SCHAR_MIN`**：表示 `signed char` 类型的最小值。
- **`SCHAR_MAX`**：表示 `signed char` 类型的最大值。
- **`UCHAR_MAX`**：表示 `unsigned char` 类型的最大值。
- **`SHRT_MIN`**：表示 `short int` 类型的最小值。
- **`SHRT_MAX`**：表示 `short int` 类型的最大值。
- **`USHRT_MAX`**：表示 `unsigned short int` 类型的最大值。
- **`INT_MIN`**：表示 `int` 类型的最小值。
- **`INT_MAX`**：表示 `int` 类型的最大值。
- **`UINT_MAX`**：表示 `unsigned int` 类型的最大值。
- **`LONG_MIN`**：表示 `long int` 类型的最小值。
- **`LONG_MAX`**：表示 `long int` 类型的最大值。
- **`ULONG_MAX`**：表示 `unsigned long int` 类型的最大值。
- **`LLONG_MIN`**：表示 `long long int` 类型的最小值。
- **`LLONG_MAX`**：表示 `long long int` 类型的最大值。
- **`ULLONG_MAX`**：表示 `unsigned long long int` 类型的最大值。

> 2. **使用变量之前，务必要对变量进行初始化**

现在的初始化方式（到C++11）

```c++
int main() {
    // 传统的初始化方式
    int a = 5;               // 拷贝初始化
    int b(6);                // 直接初始化
    string str = "Hello"; // 拷贝初始化
    string str2("World"); // 直接初始化

    // 列表初始化
    int c = {7};             // 拷贝列表初始化
    int d{8};                // 直接列表初始化
    int e{};                 // 值初始化（初始化为0）
    string str3{};      // 值初始化（初始化为空字符串）

    // 使用 auto 关键字
    auto f = 9;              // 类型是 int
    auto str4 = "Auto";      // 类型是 const char*
    auto vec = {1, 2, 3};    // 类型是 std::initializer_list<int>

    // 使用智能指针
    std::unique_ptr<int> ptr1 = std::make_unique<int>(10);
    auto ptr2 = std::make_unique<int>(20); // 自动类型推导
    std::shared_ptr<int> ptr3 = std::make_shared<int>(30);
    auto ptr4 = std::make_shared<int>(40); // 自动类型推导
}
```

<table><tr><td bgcolor = orange>        为了提高程序的可移植性，建议使用long long 数据类型   </td></tr></table>

***

#### 3.1.6 整型字面值

C++有三种表示整型的方式：8进制（老师UNIX版本）、10进制、16进制（黑客常用），在默认情况下，cout以十进制形式显示整数。不管怎么显示，整型在计算机中是以2进制存储的（0 和1）。

iostream提供了三个控制符用于控制输出

dec

> decimal      adj.n.    十进制的

hex

> hexadecimal   adj.n     十六进制的

oct

> octal   adj.n.   八进制的

```c++
cout<<dec;                               //改变输出流，修改整数输出方式为：十进制。
cout<<hex;                               //修改为：十六进制的
cout<<oct;                               //修改为： 八进制
```

以上三条语句都不会在屏幕上显示任何内容，单纯更改cout显示整数的方式。

---

#### 3.1.7 C++如何确定常量的类型

==第一步：==观察数字的后缀，例如 2500L （或者小写），表示2500数字存储为long类型，同样还有很多后缀类型。

==第二步：==考察数字长度，对于不带后缀的十进制整数，将使用下面几种类型中能够存储该数的最小类型来表示。例如：在int为16位、long长度为32位的计算机系统上，20000记为int类型，40000记为long类型，3000000000记为longlong数据类型。

此外十六进制一般都是被记为unsigned int ，因为十六进制通常被用来表示内存地址，是没有符号的。

最后C++默认将整型常量存储为int 类型。

---

#### 3.1.8 char 类型：字符和小整数

char类型是专为存储字符(字母和数字)而设计的

一般情况下，C++实现都是使用其主机系统所使用的编码，一般是ASCII码。

C++中，使用cin和cout对字符char类型进行了自动转换操作，示例：

```c++
int main(){
    char ruan;
    cout<<"请输入一个字符"<<endl;
    cin>> ruan;
    cout<<"您输入的字符是"<<ruan<<"字符"<<endl;
}
```

输出：

```cmd
C:\Users>请输入一个字符
M
C:\Users>您输入的字符是M字符
```

解释：**输入时，**cin将键盘输入的M转换为77，并且存储在ruan的那一块内存中，**输出时，**cout将所存储的77转换为字符M。

代码中的'M'的对应的ASCII码值为77，其实也是一个整数，所以能够进行整数的运算。

> 这里补充介绍了成员函数cout.put()    主要用于早期版本C++的cout不能正常处理字符

这个函数用于输出一个字符。例如<code> cout.put("!"); </code>    对应输出  <code> ! </code>   ，提供了另一种显示字符的方法，代替了cout

 

此外，还有一些字符是不方便表示的，不能直接通过敲击键盘输入到程序中的，C++提供了一种特殊的方法———转义序列，如下表：

| 字符名称       | ASCII 编号 | 转义序列 | 十进制 ASCII 码 | 十六进制 ASCII 码 |
| -------------- | ---------- | -------- | --------------- | ----------------- |
| 换行符         | LF         | `\n`     | 10              | 0x0A              |
| 回车符         | CR         | `\r`     | 13              | 0x0D              |
| 水平制表符     | HT         | `\t`     | 9               | 0x09              |
| 垂直制表符     | VT         | `\v`     | 11              | 0x0B              |
| 退格符         | BS         | `\b`     | 8               | 0x08              |
| 换页符         | FF         | `\f`     | 12              | 0x0C              |
| 警告（响铃）符 | BEL        | `\a`     | 7               | 0x07              |
| 反斜杠         |            | `\\`     | 92              | 0x5C              |
| 单引号         |            | `\'`     | 39              | 0x27              |
| 双引号         |            | `\"`     | 34              | 0x22              |
| 问号           |            | `\?`     | 63              | 0x3F              |
| 空字符         | NUL        | `\0`     | 0               | 0x00              |

> ==补充：==

1. 现在，C++逐渐支持通用字符集Unicode，包括了大量字符，ASCII码只是Unicode的一个子集。
2. 在某些硬件属性的要求下，char虽然在默认情况下没有符号，但是实际上char分为了signed char 和unsigned char。
3. 当遇到某些字符无法处理时，处理使用通用字符集，还可以使用wcin和wcout来处理wchar_t(宽字符类型流)。
4. 在此基础上仍然还有一些字符无法处理，C++11支持了char16_t和char32_t。

***

####3.1.9 bool类型

布尔类型，任何非零值都可以转换为true，而0转换为false

***

### 3.2 const 限定符

const可以用于将修改的量更改为**只读**。

***

### 3.3 浮点数

- **`float`**：单精度浮点型，通常占 4 个字节。
- **`double`**：双精度浮点型，通常占 8 个字节。
- **`long double`**：扩展精度浮点型，通常占 8、12 或 16 个字节，具体取决于实现。

***

#### 3.3.1 书写浮点数

*  标准小数点表示法，如                      `3.14 `         常规                                   适用于精确表示某个小数
* E表示法，如                                       `3.14E5`     表示3.14乘以100,000       更适用于表示非常大或者非常小的数

（这个3.14E5可以理解为3.14小数点再往右移动5位）

***

#### 3.3.2 浮点类型

| 类型          | 描述                       | 典型大小         | 有效位数（精度）                     | 范围                               |
| ------------- | -------------------------- | ---------------- | ------------------------------------ | ---------------------------------- |
| `float`       | 单精度浮点数               | 4 字节           | 约 7 位十进制数字                    | 1.2E-38 到 3.4E+38                 |
| `double`      | 双精度浮点数               | 8 字节           | 约 15 位十进制数字                   | 2.3E-308 到 1.7E+308               |
| `long double` | 扩展精度浮点数（平台相关） | 8 字节或 16 字节 | 通常至少 15 位十进制数字（通常更高） | 1.2E-4932 到 1.1E+4932（平台相关） |

>  通常cout在输出的时候，会删除结尾的0.

***

#### 3.3.3 浮点常量

通常情况下，如果希望是float类型，就使用F后缀（都是无所谓大小写），如果希望是long double 类型，就使用L后缀

***

#### 3.3.4 浮点数的优缺点

* 优点：表示了整数之间的值，增大了计算机可以表达数字的范围
* 缺点，浮点数的运行速度不行，而且运算时可能会丢失精度。

***

### 3.4 C++算术运算符

| 运算符 | 描述              | 示例           | 结果                 |
| ------ | ----------------- | -------------- | -------------------- |
| `+`    | 加法              | `a + b`        | 将 `a` 和 `b` 相加   |
| `-`    | 减法              | `a - b`        | 将 `b` 从 `a` 中减去 |
| `*`    | 乘法              | `a * b`        | 将 `a` 和 `b` 相乘   |
| `/`    | 除法              | `a / b`        | 将 `a` 除以 `b`      |
| `%`    | 取模（取余）      | `a % b`        | `a` 除以 `b` 的余数  |
| `++`   | 自增（前缀/后缀） | `++a` 或 `a++` | 将 `a` 增加 1        |
| `--`   | 自减（前缀/后缀） | `--a` 或 `a--` | 将 `a` 减少 1        |
| `-`    | 负号（取反）      | `-a`           | `a` 的负值           |

***

#### 3.4.1 运算符的优先级和结合性

仅当两个两个运算符被用于同一操作数时，优先级和结合规则生效。（和我们自然状态下的优先级相同）

***

#### 3.4.2 除法分支

除法操作符的最终行为取决于操作数的类型，如果操作数都是整数，那么会执行整数除法（丢掉后面的小数精度，使最后结果是一个整数）。

C++在对不同类型的数进行计算时，喜欢将它们转换为同一类型。

***

#### 3.4.3 求模运算符

***

#### 3.4.4 类型转换

##### 3.4.4.1 初始化和赋值类型的转换。

C++经常会遇到类型转换的时候：

* 将一种算术类型赋值给另一种算术类型，C++对值进行类型转换。
* 表达式中包含不同中类型时，C++先转换为同一种再执行运算。
* 将参数传递给函数时，C++对值进行转换 。

C++通常会对数值进行类型转换，类型转换会遇到的问题：

1. <u>较大</u> 浮点数 转 <u>较小</u> 浮点数，会丢失精度。
2. 浮点数转为整数，直接小数部分全丢。
3. <u>较大</u> 整型 转 <u>较小</u> 整型,通常只复制最右边的字节。

##### 3.4.4.2以{ }方式初始化时进行的转换(C++11)

C++将使用大括号进行初始化的操作称为列表初始化，这种初始化对类型转换的要求更为严格。

1. 不允许转换的类型 “**缩窄**”                       `通俗说就是不允许float转int，转换条件是编译器要知道目标变量能够正确地存储赋给它的值。`
2. 不允许使用变量初始化                           `假如x= 50; char ruan ={x};任然是不被允许的，因为列表初始化不允许被变量初始化。`

##### 3.4.4.3 表达式中的转换

当同一个表达式中包含两种不同的变量类型的时候，C++会使用类型转换，通常情况下是会自动转换为int类型。（因为在计算机中，使用整型能够提高计算机的运行速度）

当不同类型进行算术运算时，C++一般选择将较小的类型转换为较大的类型来保留计算的**精度**。（较大的类型具有更高的优先级）

##### 3.4.4 传递参数时的转换

传递参数的转换通常由C++函数原型控制（所以是可以修改的，但是不建议），一般情况下对float提升为double精度，其他的都提升为整型。

##### 3.4.5 强制类型转换（建议网上视频巩固）

每种强制类型转换在 C++ 中都有其特定的用途和适用场景：

- **C 风格转换**：不推荐使用，因为它不安全且不明确。
- **`static_cast`**：用于良性转换，编译时进行。
- **`dynamic_cast`**：用于类层次结构中的安全向下转换，运行时进行。
- **`const_cast`**：用于去除或增加常量性。
- **`reinterpret_cast`**：用于重新解释位模式，需小心使用。

> **C 风格转换**：

语法：`目标类型 变量名 = (目标类型) 原变量;`

> **`static_cast`**:

语法：`目标类型 变量名 = static_cast<目标类型>(原变量);`

> **`dynamic_cast`**:

语法：`派生类指针或引用 = dynamic_cast<派生类类型>(基类指针或引用);`

> **`const_cast`**:

语法：`非 const 类型指针或引用 = const_cast<非 const 类型>(const 类型指针或引用);`

> **`reinterpret_cast`**:

语法：`目标类型指针或引用 = reinterpret_cast<目标类型>(原类型指针或引用);`

***

#### 3.4.5 C++中的auto声明

C++11新增了一种能够通过初始值的类型推断变量类型的C语言关键字。

```c++
auto n = 100;          //n就会被推断成是一个int
```

当使用简单类型时，不建议使用auto（书上原话说会让你误入歧途），auto往往是处理复杂类型时，如标准模板库（STL）中的类型时，auto的优势才体现出来。

***

##第四章： 复合类型

C++ 中的复合类型（compound types）是由基本类型（如 `int`、`char` 等）构成的更复杂的数据类型。复合类型包括指针、引用、数组、枚举、结构体和类。

### 4.1 数组

数组是 C++ 中的一种基本数据结构，用于存储一组相同类型的元素。数组在内存中占用连续的空间，数组的元素通过索引进行访问。

数组的声明方式：    `数组元素类型 数组名[数组长度];`

数组长度不能是变量，必须是整型常数或者const修饰的值。

数组通过下标（或索引）访问具体的值。

#### 4.1.2 数组的初始化规则

C++对于数组的初始化有几条规则：

1. 只有在定义数组的时候才能使用初始化，之后就不能使用了，也不能将一个数组赋给另一个数组。
2. 如果只对数组的一部分进行初始化，则编译器会把其他元素设置为0。

***

#### 4.1.3 C++数组初始化方法

前面说过，C++11将使用大括号的初始方法（列表初始化），来作为一种通用的初始化方法，可以适用于所有的类型。

| 初始化方式                 | 语法示例                                    | 描述                                                         |
| -------------------------- | ------------------------------------------- | ------------------------------------------------------------ |
| 默认初始化                 | `int arr[5];`                               | 数组元素未初始化，元素值未定义。                             |
| 列表初始化（显式大小）     | `int arr[5] = {1, 2, 3};`                   | 指定数组大小，并用列表中的值初始化元素，未列出的元素初始化为零。 |
| 列表初始化（自动大小）     | `int arr[] = {1, 2, 3, 4, 5};`              | 根据列表元素的数量自动推断数组大小。                         |
| 列表初始化（全部为零）     | `int arr[5] = {0};`                         | 初始化所有元素为零。                                         |
| 列表初始化（部分为零）     | `int arr[5] = {1};`                         | 仅初始化第一个元素为 1，其他元素为零。                       |
| 列表初始化（无值）         | `int arr[5] = {};`                          | 初始化所有元素为零。                                         |
| 值初始化                   | `int* arr = new int[5]();`                  | 动态分配数组并将所有元素初始化为零。                         |
| 动态数组初始化（默认）     | `int* arr = new int[5];`                    | 动态分配数组，元素未初始化。                                 |
| 动态数组初始化（显式大小） | `int* arr = new int[5]{1, 2, 3};`           | 动态分配数组并用列表中的值初始化，未列出的元素初始化为零。   |
| 动态数组初始化（部分为零） | `int* arr = new int[5]{1};`                 | 动态分配数组，仅初始化第一个元素为 1，其他元素为零。         |
| 动态数组初始化（全部为零） | `int* arr = new int[5]{};`                  | 动态分配数组并将所有元素初始化为零。                         |
| 标准库容器 `std::array`    | `std::array<int, 5> arr = {1, 2, 3, 4, 5};` | 使用 `std::array` 初始化，并指定大小和初始值。               |

C++的标准模板库（STL）提供了一种数组的替代品——模板类 Vector，而C++11新增了模板类array，比传统的数组更加方便、灵活。

***

### 4.2 字符串

字符串是存储在内存中的连续字节中的一系列字符。C++中包含了两种：

1. 来自于C语言的常常被称作**C风格字符串(C-style string)**
2. 基于string类库的方法

C风格字符串具有一种特殊的性质：以空字符(null character)结尾， 空字符被写作\0，其ASCII码为0，用来标记字符串的结尾。

> 为什么需要 `'\0'`

1. **字符串长度**：没有 `'\0'`，我们无法确定字符串的长度。例如，标准库函数 `strlen` 通过查找 `'\0'` 来确定字符串的长度。
2. **字符串处理**：许多字符串处理函数（如 `strcpy`、`strcat` 等）都依赖 `'\0'` 来确定字符串的结束。

```c++
char ruan[5] = {'a','b','c','d','e'};    //错误的，并不是字符串，而是由字符组成的数组
char mou[5] = {'a','b','c','\0'};        //正确的，是字符串
```

以上的字符串的正确表达方式过于麻烦(由大量' '，并且要记住末尾必须是\0)，有一种更好的方法：

```c++
char ruan[11]="Hello, Ruan"                      //别忘了\0 也占一位
char mou[]="i am mrs Mou"                        //让计算机统计长度
```

用括号括起的字符串隐式地包括结尾的空字符，因此不需要显式地包括它（就是没必要自己手动加上'\0'），一般C++通过键盘输入，将字符串读入char数组中时，会自动加上结尾的空字符，所以<u>在确定存储字符串所需的最短数组时，别忘了将结尾的空字符计算在内。</u>

<table><tr><td bgcolor=orange>单引号'a'和双引号"a"的区别，也就是字符与字符串的区别，字符串包含了两个字符：'a'和'\0'</td></tr></table>

***

#### 4.2.1 拼接字符串常量

字符串不会被空格、制表符、换行符打断，它会自动拼接为一个。

***

#### 4.2.2 在数组中使用字符串

***

#### 4.2.3 字符串输入

一般使用关键字cin ，而cin使用空白（**空格、制表符、换行符**）来确定字符串的结束位置，读取完成后自动在末尾添加空字符。

`例如：              ruan          (大约就是一个单词)  `

请看下面这一段程序，它有一个很有趣的点：

```c++
int main() {
	string name;
	string food;
	cout << "请输入姓名：" << endl;
	cin >> name;
	cout << "请输入食物" << endl;
	cin >> food;
	cout << name << "在吃" << food << endl;
}
```

![](.\asset\程序截图0529.png)

我输入的是<code>ruan orange</code>  ，因为中间存在空格，所以cin只是将ruan读到，并且存储在**name**数组中，然后orange依然在输入队列中。然后当程序遇到第二个输入 <code> cin>>food </code>的时候，cin直接读到输入队列中还存放着有字符串orange ，所以无需输入，而是直接将读到的字符串orange 存储在**food**数组中。

***

#### 4.2.4  每次读取一行字符串输入

就上面的输入方式（使用cin），我们无法读取超过一个单词的输入，为此，istream包含了一些面向行的类成员的函数：<code> getline() </code>和<code> get() </code>，这两个函数都是读到一行输入，直到遇到==换行符==。

> 1. 面向行的输入： <code> getline() </code>

cin.getline() 提供两个参数，（存储输入行的数组的名称  ,    要读取的字符数  ），例如：

```c++
cin.getline(name, 20);                  //将姓名存储到一个包含20个元素的name数组中。
```

> 2. 面向行一个字符一个字符的输入: <code> get() </code>

cin.get()和cin.getline 接受一样的参数。

但是二者的**区别**是：  getline()  在读到==换行符==之后，就会自动丢弃换行符。

​                                而get（）在读到==换行符==之后，并不会丢弃==换行符==，而是保留在输入队列中，假如我们连续两次两次调用get()，例如：

<code>cin.get(name,20);</code>

<code>cin.get(age,20);</code>

第二行就会一上来就读到第一行屁股后面的换行符，它判断为已经到达行尾，而没有发现任何可以读取的内容。**cin.get()需要借助帮助才能跨越换行符。**

一般想用get来输入的话，是这样：                                     使用一个没有参数的get()来处理换行符

```c++
cin.get(name,20);                  //第一行正常输入
cin.get();                         //第二行用来处理换行符，这一行都不会显示
cin.get(age,20);                   //第三行就可以正常输入了
```

另一种写法是:

```c++
cin.get(name,20).get();           //这样等同于在第一行输入的语句后面添加了一个cin.get();
```

<font color="red">补充：</font>这里之所以可以这样做：是因为cin.get(Name,ArraySize)本身也会返回一个cin对象，这个cin对象看到屁股后面跟着一个 get()，又会自动调用后面的cin.get()。这个法则同样适用于cin.getline:

```c++
cin.getline(Name1,ArraySize).getline(Name2,ArraySize);       //这句话等同于连续输入两行getline并保存在Name1和Name2中。
```

<u>使用 get() 比 getline() 将会更加细致，但是也增加了麻烦。</u>

***

#### 4.2.5 小结

- `cin >>` 会自动跳过输入中的空白字符，包括空格、制表符和换行符。
- `cin.get()` 会读取并保留空白字符，包括换行符。
- `cin.getline()` 会读取整行输入，并丢弃换行符。

***

###4.3 string 类简介

C++98标准在C++中添加了string类，要使用的话，需要包含头文件<code> <string> </code>

相对于char数组来说，char数组只是存储一个字符串的存储单元，而string 类变量是一个表示字符串的实体。

#### 4.3.1 C++字符串初始化

C++中的string类也支持列表初始化:

```c++
string ruan = {" the name of someone"};        //相似于  char ruan[] = {" the name of someone"};
string mou {" the name of a lady"};            //相似于  char mou[] {" the name of a lady"};
```

***

#### 4.3.2 赋值、拼接和附加

##### 1. 赋值

数组不能将一个数组赋给另一个数组，但是可以将一个string 对象赋给另一个string对象。

##### 2.拼接和附加

string对象允许使用+运算符将两个string对象拼接起来。

string 对象允许使用+= 运算符将字符串追加到string字符串的末尾。

***

#### 4.3.3 string类的其它操作

在C++添加了string类之前，主要是使用cstring头文件所包含的一些函数，通常被称为C风格字符串。

> 字符串操作函数

C++ 提供了许多处理字符串的函数，它们依赖于 `'\0'` 来确定字符串的边界。例如：

- `strlen(str)`：返回字符串的长度，不包括 `'\0'`。
- `strcpy(dest, src)`：将源字符串复制到目标字符串，包含 `'\0'`。
- `strcat(dest, src)`：将源字符串连接到目标字符串的末尾。

在使用字符数组的时候，总是存在目标数组过小，无法存放指定信息的风险,C函数库提供了与strcat()和strcpy()相似的函数——strncat()和strncpy()，它们指出目标数组最大允许长度的第三个参数，因此更加安全，但也增大了编写程序的复杂程度。

***

#### 4.3.4 string类I/O

在未初始化时，string 的长度被自动设置为0，而自动根据你的字符串的长度来自动进行调整。

而char数组是预先设置好了的。

***

#### 4.3.5 其他形式的字符串字面值

C++ 提供了多种形式的字符串字面值，以支持不同的字符编码和特殊字符串处理需求，包括：

- 普通字符字符串字面值 (`char`)
- 宽字符字符串字面值 (`wchar_t`)
- UTF-8 字符串字面值 (`char8_t`)
- UTF-16 字符串字面值 (`char16_t`)
- UTF-32 字符串字面值 (`char32_t`)
- 原始字符串字面值

通过这些不同形式的字符串字面值，C++ 程序员可以灵活地处理不同类型的字符串数据。示例：

```c++
int main() {
    // 普通字符字符串字面值
    const char* str = "Hello, World!";
    std::cout << str << std::endl;

    // 宽字符字符串字面值
    const wchar_t* wstr = L"Hello, World!";
    std::wcout << wstr << std::endl;

    // UTF-8 字符串字面值
    const char8_t* u8str = u8"Hello, World!";
    std::cout << reinterpret_cast<const char*>(u8str) << std::endl;

    // UTF-16 字符串字面值
    const char16_t* u16str = u"Hello, World!";
    std::u16string u16(u16str);
    std::wcout << u16.c_str() << std::endl;

    // UTF-32 字符串字面值
    const char32_t* u32str = U"Hello, World!";
    std::u32string u32(u32str);
    std::wcout << u32.c_str() << std::endl;

    // 原始字符串字面值
    const char* rawstr = R"(Hello, "World"!\nThis is a raw string literal.)";
    std::cout << rawstr << std::endl;

    return 0;
}
```

增加其他形式的字符串的字面值的优点：

- **多语言支持**：通过宽字符和 Unicode 字符串字面值，C++ 能够处理不同语言的文本，支持国际化和本地化。
- **编码灵活性**：不同的编码方式（UTF-8、UTF-16、UTF-32）提供了灵活的选择，以满足不同应用场景的需求，如存储效率、兼容性、直接访问 Unicode 码点等。
- **简化编程**：原始字符串字面值简化了处理包含特殊字符的字符串的操作，减少了编程错误和代码复杂性。

***

### 4.4 结构简介

结构体（`struct`）是一种用户定义的数据类型，它允许将不同类型的数据组合在一起，形成一个新的类型。这使得处理相关联的数据更加方便和直观。

```c++
// 定义一个结构体来表示一个学生
struct Student {
    std::string name;
    int age;
    float gpa;
};
int main(){
    // 声明一个结构体变量并初始化
    Student student1 = {"Alice", 20, 3.8};

    // 访问和修改结构体成员
    std::cout << "Name: " << student1.name << std::endl;
    std::cout << "Age: " << student1.age << std::endl;
    std::cout << "GPA: " << student1.gpa << std::endl;
}
```

#### 4.4.1 在程序中使用结构体

1. **定义结构体**：
   - 使用 `struct` 关键字来定义（可以在声明中省去这个关键字）。
   - 结构体可以包含不同类型的成员（变量）。
   - 成员可以是基本数据类型、数组、指针，甚至是其他结构体。
2. **声明和访问成员**：
   - 通过点运算符（`.`）访问结构体成员。
3. **默认公有访问权限**：
   - 结构体的成员默认是公有的（==public==），与类（`class`）不同。
4. **与类的区别**：
   - 结构体和类在语法上非常相似，主要区别在于默认访问权限（结构体默认公有，类默认私有）。
   - 结构体通常用于简单的数据组合，而类更常用于面向对象编程。



结构体可以在函数内部（局部声明）或者函数外部（全局声明）。

| 特性         | 局部声明的结构体                           | 全局声明的结构体                                       |
| ------------ | ------------------------------------------ | ------------------------------------------------------ |
| **定义位置** | 在函数或代码块内部                         | 在所有函数和代码块外部（通常在文件的顶部）             |
| **作用域**   | 仅在定义它的函数或代码块内部可见           | 在整个文件中（或通过 `extern` 关键字在其他文件中）可见 |
| **生命周期** | 与所在代码块或函数相同                     | 在程序的整个生命周期内存在                             |
| **可访问性** | 只能在声明它的范围内使用                   | 可以在多个函数和文件中访问和使用                       |
| **命名冲突** | 避免了结构体名称在全局范围内的污染         | 可能导致全局命名空间污染，增加命名冲突的风险           |
| **模块化**   | 提高代码的模块化程度，仅在需要的范围内定义 | 在多个地方使用相同数据类型                             |
| **应用场景** | 仅在单个函数或代码块内需要的数据类型       | 需要在多个函数或模块中共享的数据类型                   |

***

#### 4.4.2 C++结构体初始化

首先C++结构体支持列表初始化，例如<code> Student student1 = {"Alice", 20, 3.8}; </code>  （等号是可以省去的）

其次需要注意的是：假如初始化时的大括号没有包含任何东西，那么各个成员都将会被设置成0.

***

#### 4.4.3 结构可以将string类作为成员吗

当然可以，只要编译器版本支持，并且能够访问命名空间std。

***

#### 4.4.4 其他结构体属性

##### 1. 允许结构体作为参数传递给函数，也允许结构体作为函数返回值

##### 2. 允许使用运算符(=)将一个结构体赋值给另一个结构体（前提是它们必须是相同结构）

这种方式被称为成员赋值

##### 3. C++允许定义没有名称的结构体（匿名结构体）

通常是用作在结构体嵌套的结构体中出现。可以作为结构体的成员出现，被结构体直接访问，用处是数据看起来更加直观。

***

#### 4.4.5 结构数组

有时候我们会遇到多个结构体对象，例如一个Student数量不够，我们可以创建一个Student数组来保存多个Student结构体。

```c++
// 定义一个表示学生的结构体
struct Student {
    std::string name;
    int age;
    float gpa;
};
int main(){
    Student students[3] = {             //声明结构体数组的方式
        {"Alice", 20, 3.8},
        {"Bob", 22, 3.6},
        {"Charlie", 19, 3.9}
    };

    // 遍历结构体数组并打印每个学生的信息
    for (int i = 0; i < NUM_STUDENTS; ++i) {
        std::cout << "Student " << i + 1 << ":\n";
        std::cout << "Name: " << students[i].name << std::endl;
        std::cout << "Age: " << students[i].age << std::endl;
        std::cout << "GPA: " << students[i].gpa << std::endl;
        std::cout << std::endl;
    }
}
```

***

#### 4.4.6 结构中的位字段

结构体中的位字段（Bit Fields）是一种 C++ 中的特性，允许程序员精确控制结构体中每个成员变量所占用的位数。通过使用位字段，可以有效地利用内存，并实现对位级别的操作，例如定义位域表示硬件寄存器中的各个位或对节省内存的要求很高的数据结构。

1. **位级别的操作**：位字段允许程序员直接访问和操作结构体成员的位，而不是整个字节或更大的单元。
2. **节省内存**：位字段允许定义成员变量所占用的位数，可以在内存使用上更加高效。
3. **硬件相关的编程**：位字段常用于与硬件相关的编程，例如与寄存器通信或处理硬件设备的控制信号。
4. **优化存储**：在需要优化内存占用的情况下，可以使用位字段来节省内存空间。

语法：

```c++
struct BitFieldStruct {                  //正常定义结构体的名字
    dataType memberName : numberOfBits;        //数据类型   成员变量名  ：   成员变量所占用的位数
};
```

使用位字段可以在特定场景下提供更高效的内存使用和位级别的操作，但需要注意平台和编译器的差异，以确保程序的正确性和可移植性。

***

### 4.5 共用体

共用体（Union）是一种特殊的数据结构，在C++中允许将多个成员共享同一块内存空间。共用体的所有成员都从同一内存位置开始，因此修改一个成员会影响到其他成员的值。共用体的大小等于它最大的成员所占用的内存空间。

1. **内存共享**：共用体的成员==共享同一块内存空间==，可以实现不同数据类型的转换或对同一数据的不同视图。
2. **节省内存**：共用体的大小等于最大成员的大小，因此可以节省内存空间。
3. **灵活性**：共用体可以用于处理需要多种数据类型表示的情况，例如处理不同的数据格式或通信协议。
4. **硬件相关的编程**：共用体常用于与硬件相关的编程，例如与寄存器通信或处理硬件设备的控制信号。

```c++
union UnionName {                     //定义名称使用关键字union
    dataType member1;                 //只能存储同种数据类型的数据
    dataType member2;
    // 可以定义更多的成员
};
```

>  <font color = red>**注意事项:**</font>

- **数据共享**：共用体的所有成员共享同一块内存空间，修改一个成员会影响到其他成员的值。
- **数据转换**：共用体可用于不同数据类型的转换，但需要注意成员的存储顺序和大小端字节序。
- **访问正确性**：在使用共用体时，需要确保访问正确的成员，避免未定义的行为或数据损坏。

共用体是一种灵活且强大的工具，用于处理需要多种数据表示的情况，但在使用时需要小心确保访问的正确性和数据的一致性。

***

### 4.6 枚举

枚举类型（Enumeration）是一种用户定义的数据类型，用于定义一组相关的命名常量。枚举类型可以为一组常量赋予易于记忆和理解的名称，使代码更易读和维护。

1. **定义命名常量**：枚举类型允许定义一组命名常量，这些常量表示一组固定的值，例如状态、选项等。
2. **提高可读性**：使用枚举类型可以避免魔法数字（hard-coded numbers），使代码更容易理解。
3. **编译时检查**：枚举类型在编译时可以提供类型检查，减少错误。
4. **简化代码维护**：修改枚举类型中的常量只需修改定义处，不需要修改所有使用这些常量的地方。

> 魔法数字（Magic Number）是指代码中直接使用的、没有明显意义的数值或字符串。这些数值或字符串往往缺乏上下文解释，使代码难以理解和维护。

语法：

```c++
enum EnumName {             
    Enumerator1,
    Enumerator2,
    // 更多的枚举器
};
```

举例：

```c++
enum Color {
    RED,    // 默认值为 0
    GREEN,  // 默认值为 1
    BLUE    // 默认值为 2
};

int main() {
    Color myColor = GREEN;

    if (myColor == GREEN) {
        std::cout << "The color is green." << std::endl;
    }

    return 0;
}
```

在C++中，枚举类型（`enum`）的枚举器默认是`int`类型。可以在C++11及更高版本中显式指定枚举类型的底层类型。

#### 4.6.1 默认值与自定义值

枚举器的默认值从 0 开始递增，但可以手动指定值：

```c++
enum Weekday {
    SUNDAY = 0,
    MONDAY = 1,
    TUESDAY = 2,
    WEDNESDAY = 3,
    THURSDAY = 4,
    FRIDAY = 5,
    SATURDAY = 6
};
```

也可以指定部分枚举器的值，未指定的会基于前一个值递增：

```c++
enum Weekday {
    SUNDAY = 0,
    MONDAY,        // 1
    TUESDAY = 5,   // 5
    WEDNESDAY,     // 6
    THURSDAY = 10, // 10
    FRIDAY,        // 11
    SATURDAY       // 12
};
```

- 枚举类（`enum class`）提供了更严格的类型安全性，不会隐式转换为整数类型，并且默认底层类型也是`int`。

***

### 4.7 指针和自由存储空间

计算机在存储数据时必须具备的三种基本属性：

* 信息要存储在哪儿
* 存储的值是多少
* 存储的信息是什么类型

指针这种数据类型，存储的是值的地址，而不是值本身。对于指针本身来说，也有自己的地址，所以就存在**指针的指针**。

**当我们需要找到常规变量的地址时**，我们只需要对变量应用==取址运算符==<code> & </code>，就可以获得它的位置。通常情况下，计算机显示地址是使用**十六进制表示法**，因为这是常用于内存的表示法。

**当我们需要获得该地址存储的值时**，我们就会用到间接值（indirect value）或者==解引用运算符==<code> * </code> (C++会通过上下文来判定这是乘法的*，还是解引用的运算符)

#### 4.7.1 声明和初始化指针

指针变量声明的一般形式为：

```c++
type *var-name;
```

在这里，**type** 是指针的基类型，它必须是一个有效的 C++ 数据类型，**var-name** 是指针变量的名称。顺便说一句，*两边的空格是可选的。

int* 是指指向int 类型的指针，int*本身也就是一种复合类型，就像int[]一样。

虽然不同的数据类型指针指向长度不同的数据类型，但是指针的长度（**地址长度**）一般都是相同的，计算机中地址长度一般由操作系统而确定。

***

#### 4.7.2 指针的危险

##### 1. 空指针（Null Pointer）

指针初始化或使用不当，可能导致指针指向内存地址0（即空指针）。如果解引用空指针，会导致程序崩溃。

```c++
int* ptr = nullptr;
*ptr = 10;  // 试图解引用空指针，会导致运行时错误
```

##### 2. 野指针（Dangling Pointer）

野指针是指向无效内存地址的指针。例如，指针指向已释放的内存，或指针变量没有初始化就被使用。

```c++
int* ptr;
*ptr = 10;  // 未初始化的指针，指向随机内存地址

int* ptr2 = new int(10);
delete ptr2;
*ptr2 = 20;  // 指向已释放内存的指针，导致未定义行为
```

#####3. 内存泄漏（Memory Leak）

内存泄漏发生在动态分配的内存没有被释放，导致程序占用的内存不断增加。

```c++
void memoryLeak() {
    int* ptr = new int[10];
    // 忘记使用 delete[] 释放内存
}
```

#####4. 双重释放（Double Free）

释放同一块内存两次，会导致未定义行为，可能导致程序崩溃。

```c++
int* ptr = new int;
delete ptr;
delete ptr;  // 双重释放
```

##### 5. 缓冲区溢出（Buffer Overflow）

访问数组或缓冲区时，超出其边界，可能会覆盖其他内存数据，导致程序崩溃或安全漏洞。

```c++
int arr[5];
for(int i = 0; i <= 5; i++) {  // 访问超出数组边界
    arr[i] = i;
}
```

##### 6. 非法内存访问（Invalid Memory Access）

访问未分配的内存区域，会导致程序崩溃或产生不可预测的行为。

```c++
int* ptr = reinterpret_cast<int*>(0x12345678);  // 非法内存地址
*ptr = 10;  // 非法内存访问
```

##### 7. 指针算术（Pointer Arithmetic）和类型混淆（Type Confusion）

指针算术操作不当，可能导致指针指向错误的内存地址。类型混淆会导致解引用错误类型的指针，从而引发未定义行为。

```c++
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;
ptr += 10;  // 指针越界

void* voidPtr = &arr;
int* intPtr = static_cast<int*>(voidPtr);
double* doublePtr = static_cast<double*>(voidPtr);  // 类型混淆
*doublePtr = 3.14;
```

***

#### 4.7.3 指针和数字

指针存储的是计算机中的地址，所以==你可以将一个地址赋值给一个指针==，你就会遇到这种问题

```c++
int * ptr;
ptr = 0xB8000000 ;   //这样是错误的，计算机会认为你是将一个整数赋值给它
```

虽然计算机通常把地址当作int类型的整数来处理，但是指针不是整型，它无法判断赋给它的是一个整数还是计算机中的地址。

所以正确的方式是在这个基础上加一个类型转换即可：

```c++
ptr = (int *)0xB8000000;      //现在就可以了
```

***

#### 4.7.4 使用new来分配内存，使用delete来释放(2者成对出现)

指针的用武之地是在运行阶段分配未命名的内存以存储值。

在C++中，`new`关键字用于动态分配内存。这意味着在程序运行时，根据需要分配内存，而不是在编译时确定。这对于创建需要在运行时动态决定大小或生命周期的对象非常有用。

而<code> delete </code> 关键字用于释放指针所指向的那一片内存（*不是删除掉指针本身*）

> **基本用法**

**分配单个对象**

```c++
int* ptr = new int;  // 分配一个int类型的对象
*ptr = 5;            // 使用分配的内存
delete ptr;          // 释放分配的内存
```

<code> new int </code>告诉程序，需要找一片适合int的内存，new运算符根据类型来确定需要多少字节的内存，然后它找到这样的内存并返回它的地址。接下来将地址赋给ptr ,ptr是被声明为指向int 类型的指针。

使用`new`分配的内存不会自动初始化，除非明确指定：<code> int* ptr = new int(5);  // 分配并初始化为5 </code>

当然内存也不是无穷无尽开辟的，计算机可能由于没有足够的内存而无法满足new的请求，在较老的实现中，new 将返回0，在C++中，值为0的指针被称为**空指针**。

<font color= red>警告：</font><code> delete </code> 只能用来释放new分配的内存,但是对**空指针**使用delete是安全的

**分配数组**

使用new分配数组会返回数组第一个元素的地址。C++**使用指针数组的方式**也很简单，将指针当作数组名即可！假如我要访问数组的第3个元素的指针，<code> arr[2] </code>即可，而使用<code> * arr[2] </code>则是试着解引用第3个元素所指向的对象，如果第三个元素存放的不是指针（*例如下面的int数组*）这个<code> * arr[2] </code>就毫无意义。

```c++
int* arr = new int[10];  // 分配一个包含10个int类型元素的数组
arr[2] = 1;              // 使用分配的数组,访问第三个元素并赋值为1
cout << arr[2] << endl;  // 打印这个元素

int* ptr = arr + 3;      // 指针偏移3位
cout << ptr[-1] << endl; // 打印偏移后的元素
delete[] arr;            // 释放分配的数组内存
```

上面我分配一个包含10个int类型元素的数组，然后第三个元素我想给它存放一个1，然后打印这第三个元素的数，打印结果是1。然后当我将这个指针数组的指针偏移3位，仍然想打印这个1，就需要用<code> ptr[-1] </code>来访问了

> **示例**

**单个对象分配和释放**

```c++
#include <iostream>

int main() {
    int* ptr = new int;  // 动态分配内存
    *ptr = 10;           // 使用分配的内存
    std::cout << *ptr << std::endl;
    delete ptr;          // 释放分配的内存
    ptr = nullptr;       // 避免悬空指针
    return 0;
}
```

**数组分配和释放**

```c++
#include <iostream>

int main() {
    int* arr = new int[5];  // 动态分配数组
    for (int i = 0; i < 5; ++i) {
        arr[i] = i * 10;    // 使用分配的数组
    }
    for (int i = 0; i < 5; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
    delete[] arr;           // 释放分配的数组内存
    arr = nullptr;          // 避免悬空指针
    return 0;
}
```

##### 1.  <font color=red>**使用注意事项**</font>

1. **匹配的释放**：

   - 使用 `new` 分配的内存必须用 `delete` 释放。
   - 使用 `new[]` 分配的内存必须用 `delete[]` 释放。
   - 错误匹配会导致未定义行为，可能引起程序崩溃。

2. **避免双重释放**： 释放同一块内存多次会导致未定义行为。

   ```c++
   int* ptr = new int;
   delete ptr;
   delete ptr;  // 错误：双重释放
   ```

3. **释放后指针设为 nullptr**： 释放内存后将指针设为 nullptr，可以避免悬空指针（*也叫做野指针*）问题。

   ```c++
   int* ptr = new int;
   delete ptr;
   ptr = nullptr;  // 避免悬空指针（野指针）
   ```

如果你想在将指针设置为 `nullptr` 后仍然使用它，你需要确保在使用指针之前重新分配内存。否则，如果指针为 `nullptr`，试图对其进行解引用或访问其成员可能会导致未定义行为，因为 `nullptr` 不指向有效的内存。

##### 2. 补充知识： new在内存上的分配

> 堆区（Heap） <font size = 2 color = black>在运行的时候创建使用</font>

- **分配方式**：通过`new`、`malloc`等动态内存分配函数。
- **生命周期**：程序员手动管理，分配的内存直到调用`delete`或`free`释放前一直存在。
- **用途**：适用于需要动态分配大小和生命周期的对象，如动态数组、数据结构等。
- **管理方式**：需要程序员显式管理内存，易出现内存泄漏或悬空指针等问题。

> 栈区（Stack）  <font size = 2 color = black>在编译的时候创建使用</font>

- **分配方式**：自动分配，如局部变量、函数参数等。
- **生命周期**：自动管理，函数调用结束或作用域结束时自动释放。
- **用途**：适用于生命周期短且固定大小的对象，如局部变量、函数参数等。
- **管理方式**：由编译器自动管理，效率高，不易出现内存泄漏。

常规的变量声明：例如<code>int stackVar = 42;  // 自动分配栈内存 </code> 

***

### 4.8 指针、数组和指针算术

####4.8.1 三者关系

#####1. 数组和指针

在 C++ 中，**数组名**在大多数情况下会被隐式地**转换为**指向数组第一个元素的**指针**。例如：

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* p = arr; // arr 被隐式地转换为 &arr[0]
```

在这段代码中，`arr` 被隐式地转换为指向数组第一个元素 `arr[0]` 的指针。因此，`p` 和 `&arr[0]` 是等价的（<font size=2 color = red>同样*p和arr[0]是一样的</font>）。

##### 2. 指针算术

指针算术是基于指针所指向的数据类型的大小进行的。当对指针进行加减操作时，实际**增加**或**减少**的值是指针指向**类型的大小**。例如：

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* p = arr; // p 指向 arr[0]

p = p + 1; // p 现在指向 arr[1]
p = p - 1; // p 现在又指向 arr[0]
```

在这段代码中，`p + 1` 使指针 `p` 指向数组的下一个元素，即 `arr[1]`，而不是简单地增加一个字节。由于 `int` 类型的大小通常是 4 个字节，因此 `p + 1` 实际上增加了 4 个字节。

##### 3. 指针和数组的结合

通过指针算术，可以方便地遍历和操作数组。例如：

```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    int* p = arr;

    // 使用指针遍历数组
    for (int i = 0; i < 5; ++i) {
        cout << *(p + i) << " ";
    }
    cout << endl;

    // 使用数组名和指针的等效性
    for (int i = 0; i < 5; ++i) {
        cout << p[i] << " ";
    }
    cout << endl;

    return 0;
}
```

输出：
```
1 2 3 4 5
1 2 3 4 5
```

在这个示例中，`*(p + i)` 和 `p[i]` 是等价的，都是在访问数组 `arr` 中的元素。这是因为 `p` 是指向数组第一个元素的指针，`p + i` 指向数组的第 `i` 个元素，`*(p + i)` 获取该元素的值。

##### 4. 使用指针偏移操作数组

通过指针偏移，可以在数组中灵活地移动指针位置。例如：

```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    int* p = arr;  // p 指向 arr[0]

    // 输出初始指针指向的值
    cout << "Initial value: " << *p << endl;  // 10

    // 指针偏移3个位置
    p = p + 3;  // 现在 p 指向 arr[3]
    cout << "Value after offsetting by 3: " << *p << endl;  // 40

    // 指针偏移 -1 个位置
    p = p - 1;  // 现在 p 指向 arr[2]
    cout << "Value after offsetting by -1: " << *p << endl;  // 30

    return 0;
}
```

在这段代码中，我们通过指针偏移操作来访问数组的不同位置。初始情况下，指针 `p` 指向数组的第一个元素 `arr[0]`，然后通过 `p = p + 3` 将指针移动到 `arr[3]`，并通过 `*p` 访问该位置的值。同样，通过 `p = p - 1` 将指针移动到 `arr[2]` 并访问该值。

#### 4.8.2 小结

指针与数组结合使用在 C++ 中非常灵活和高效。理解指针算术和数组名的隐式转换，可以更好地操作和遍历数组，进行复杂的数据处理和操作。这种结合在低级编程和性能优化中非常重要和有用。使用方括号<code> [] </code>数组表示法等同于指针解引用。

此外我们可以使用<code> new() </code>运算符实现动态数组（<font size = 2 color=red>在程序运行时才创建数组，而不是在编译的过程中</font>），例如：

```c++
int size;
cin>>size;
int * ruan = new int (size);                        //在运行时才根据自己的需求创建数组
```

***

#### 4.8.3 指针和字符串

指针和字符串在 C++ 中有着密切的关系。字符串可以通过字符数组或指向字符的指针来表示和操作。理解指针与字符串的关系对于处理和操作字符串非常重要。

##### 1. 字符数组

字符数组是一种常见的字符串表示方式。字符串是以空字符 `'\0'` 结尾的字符序列。例如：

```cpp
char str[] = "Hello, world!";
```

在这段代码中，`str` 是一个字符数组，包含字符串 `"Hello, world!"` 和一个隐含的空字符 `'\0'`。

#####2. 指针和字符数组

字符数组名在大多数情况下会被隐式地转换为指向数组第一个元素的指针。例如：

```cpp
char str[] = "Hello";
char* p = str; // str 被隐式地转换为 &str[0]
```

在这段代码中，`str` 被隐式地转换为指向数组第一个元素 `str[0]` 的指针。因此，`p` 和 `&str[0]` 是等价的。

##### 3. 指针操作字符串

通过指针可以方便地操作字符串。例如：

```cpp
#include <iostream>
using namespace std;

int main() {
    char str[] = "Hello";
    char* p = str;

    // 输出字符串
    while (*p != '\0') {
        cout << *p;
        p++;
    }
    cout << endl;

    return 0;
}
```

在这段代码中，通过指针 `p` 遍历并输出字符串 `str`。指针 `p` 从字符串的第一个字符开始，每次递增一个字符，直到遇到空字符 `'\0'`。

<table><tr><td bgcolor = orange>还有一种更加简洁的方法：</td></tr></table>

可以直接用<code> cout<<str<<endl; </code>来打印这一个字符串，cout会获取到一个指针，通常情况下，cout获取到一个指针，它会打印指针的地址，但是如果这个指针的类型是char * ，那么cout就将显示指向的完整的字符串。

##### 4. 字符指针

字符指针可以直接指向字符串字面值。例如：

```cpp
char* p = "Hello, world!";
```

在这段代码中，`p` 是一个指向字符串字面值 `"Hello, world!"` 的指针。

<font color=red>注意：</font> 字符串字面值是**只读**的，因此**不能**通过指针 `p` **修改**字符串的内容。

##### 5. 使用 `std::string`

在现代 C++ 中，推荐使用 `std::string` 类来处理字符串。`std::string` 提供了丰富的成员函数和操作符，可以更方便地操作字符串：

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string str = "Hello, world!";
    cout << str << endl;

    // 使用指针遍历 std::string
    const char* p = str.c_str();
    while (*p != '\0') {
        cout << *p;
        p++;
    }
    cout << endl;

    return 0;
}
```

在这段代码中，使用 `std::string` 来处理字符串。通过 `str.c_str()` 获取指向字符串数据的指针，并通过指针遍历和输出字符串。

而且使用string类，您就不同担心字符串导致数组越界，并且可以使用赋值运算符（前面介绍过）。

***

#### 4.8.4 使用new 创建动态结构

在 C++ 中，使用 `new` 操作符可以动态地创建结构体对象。动态分配内存可以在**运行时**根据需要创建和管理对象，而不是在编译时确定对象的数量和大小。

优点：**节约内存**。

##### 1. 访问动态结构体对象

通过指针访问结构体对象的成员，有两种方式：

1. 箭头成员访问方式：` 指针->成员 `
2. 解引用访问方式:`*指针.成员`

```cpp
std::cout << "Name: " << student->name << std::endl;
std::cout << "Age: " << student->age << std::endl;
std::cout << "GPA: " << *student.gpa << std::endl;
```

##### 2. 完整示例

以下是一个完整示例，演示如何使用 `new` 创建动态结构体对象和结构体数组，并进行初始化和访问：

```cpp
#include <iostream>
#include <string>

struct Student {
    std::string name;
    int age;
    double gpa;
};

int main() {
    // 动态分配单个结构体对象
    Student* student = new Student{"John Doe", 20, 3.5};   //使用构造函数或成员初始化列表来初始化动态分配的结构体对象

    // 访问单个结构体对象
    std::cout << "Name: " << student->name << std::endl;
    std::cout << "Age: " << student->age << std::endl;
    std::cout << "GPA: " << *student.gpa << std::endl;

    // 释放单个结构体对象
    delete student;
    student = nullptr;

    // 动态分配结构体数组
    Student* students = new Student[3];

    // 初始化结构体数组
    students[0] = {"John Doe", 20, 3.5};        //在分配对象后通过指针访问和设置成员变量
    students[1] = {"Jane Smith", 22, 3.7};
    students[2] = {"Emily Davis", 19, 3.9};

    // 访问结构体数组
    for (int i = 0; i < 3; ++i) {
        std::cout << "Student " << i + 1 << ": " << students[i].name << std::endl;
    }

    // 释放结构体数组
    delete[] students;
    students = nullptr;     // 避免悬空指针

    return 0;
}
```

***

#### 4.8.5 自动存储、静态存储和动态存储以及内存4区

在C++中，变量可以存储在不同的存储区域，主要包括自动存储、静态存储和动态存储(<font size = 2 color = red>C++11还增加了第4种类型------线程存储</font>)。

1. **自动存储**：
   - 自动存储是指在函数内部声明的变量，默认情况下**存储在栈上**，这意味着执行代码块时，其中的变量会依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为**后进先出(LIFO)**。
   - 这些变量在函数调用时**自动创建**，当函数调用结束时被**自动销毁**。
   - 自动变量的生命周期受限于其所在的作用域，超出作用域后会自动销毁，是一个**局部变量**。
   - 示例：
     ```cpp
     void function() {
         int x = 10; // 自动变量
         // ...
     }
     ```

2. **静态存储**：
  
   - 静态存储是指**全局变量**和使用 **`static` 修饰符**声明的变量，存储在静态存储区域（**数据区**）。
   - 静态变量的生命周期从程序启动到程序结束，**一直存在于内存**中。
   - 静态变量只会被初始化一次，在**编译阶段**被**初始化**。
   - 示例：
     ```cpp
     static int globalVar; // 静态全局变量
     void function() {
         static int localVar; // 静态局部变量
         // ...
     }
     ```
   
3. **动态存储**：
  
   - 动态存储是通过 **`new` 和 `delete` **运算符在**堆上分配和释放**内存。
   - 动态分配的内存在程序员显式地释放之前会一直存在,生命由程序员管理，给予了极大的自由度。
   - 动态存储适用于需要在运行时动态分配内存的情况，如动态数组、对象等。
   - 使用动态存储需要**注意内存泄漏**和释放后的**悬空指针**问题。
   - 示例：
     ```cpp
     int* ptr = new int; // 动态分配内存
     delete ptr; // 释放内存
     ```

这些存储区域分别对应了内存中的4个区域：

- **代码区**：存放函数体的二进制代码，由操作系统进行管理。代码区的代码是只读共享的，利于程序调用执行，并防止修改。
- **数据区**：**BSS段**：存放未初始化的静态变量（全局与局部）以及初始化为0的静态变量（全局、局部）。**数据段**：初始化非0的静态变量（全局,局部）初始化非0的全局变量。**RODATA段**：初始化为0的全局常量,初始化非0的全局常量。
- **堆区**：堆区的内存是动态的，与栈区没有明显的分界线。使用`malloc`函数或`new`关键字向堆区申请空间，手动申请，手动释放。
- **栈区**：也是动态的，在程序运行时，由编译器自动分配内存空间。存放函数的参数值、局部变量、局部常量等。

***

### 4.9 类型整合和auto关键字

学会将数组、结构体和指针结合起来使用，auto关键字的使用：

C++中的`auto`关键字用于自动类型推断，简化了变量声明，使代码更简洁和可读。它在C++11标准中引入，并在后续版本中得到扩展。`auto`关键字在C++中大大简化了代码，使得编写和维护代码更加容易，尤其是在处理复杂类型时。通过使用`auto`，程序员可以让编译器自动推断变量的类型，从而减少代码中的冗余和潜在的错误。

>  基本用法

`auto`关键字让编译器根据初始化表达式来推断变量的类型。例如：

```cpp
auto x = 42;            // int
auto y = 3.14;          // double
auto z = "Hello, world!"; // const char*
```

在上述例子中，`x`的类型被推断为`int`，`y`的类型被推断为`double`，`z`的类型被推断为`const char*`。

> 用于迭代器

`auto`在使用复杂迭代器(这里的遍历输出语句)类型时特别有用，例如STL容器中的迭代器：

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};
for (auto it = vec.begin(); it != vec.end(); ++it) {
    std::cout << *it << " ";
}
```

> 使用范围for循环

在范围for循环中，`auto`可以简化元素类型的声明：

```cpp
std::vector<std::string> words = {"Hello", "world"};
for (auto& word : words) {
    std::cout << word << " ";
}
```

> 与auto结合的函数返回类型

在C++14及以后版本中，可以使用`auto`关键字作为函数的返回类型，使得函数返回类型也能自动推断：

```cpp
auto add(int a, int b) {
    return a + b;
}
```

> `decltype`和`auto`

`auto`也可以与`decltype`结合使用，以推断类型：

```cpp
int a = 1;
decltype(a) b = 2; // b 的类型与 a 相同，为 int
```

> Lambda表达式

在C++14及以后版本中，`auto`可以用于lambda表达式的参数类型推断：

```cpp
auto lambda = [](auto x, auto y) {
    return x + y;
};
std::cout << lambda(1, 2) << std::endl;     // 3
std::cout << lambda(1.5, 2.5) << std::endl; // 4.0
```

> <font  color=red>注意事项</font> 

1. **初始化**：`auto`变量必须在声明时初始化，因为编译器需要根据初始值来推断类型。
2. **推断规则**：`auto`会丢弃顶层const和引用，但保留底层const和引用。例如：

    ```cpp
    const int a = 10;
    auto b = a; // b 的类型为 int
    auto& c = a; // c 的类型为 const int&
    ```

***

### 4.10 数组的替代品（STL标准模板库）

#### 4.10.1 模板类 vector

`std::vector`是C++标准库中的一个模板类，用于表示动态数组。它提供了**自动调整大小**的功能，并且能够高效地进行元素的添加、删除和访问操作。`std::vector`是一个广泛使用的容器，因为它既灵活又高效。以下是`std::vector`的详细介绍：

##### 1.基本特性

- **动态大小**：`std::vector`可以根据需要自动调整其大小。
- **连续内存存储**：`std::vector`中的元素在内存中是连续存储的，这使得它们可以高效地进行随机访问。
- **自动内存管理**：`std::vector`会自动管理内存分配和释放（<font size = 2 color=red>自动new和delete</font> ），用户无需手动管理内存。

##### 2. 创建和初始化

创建和初始化`std::vector`有多种方式：

```cpp
#include <vector>            //使用vector，必须先包含vector头文件
#include <iostream>

int main() {
    // 默认构造函数，创建一个空的 vector
    std::vector<int> vec1;

    // 指定初始大小的构造函数，所有元素初始化为默认值
    std::vector<int> vec2(10); // 10 个元素，初始值为 0

    // 指定初始大小和初始值的构造函数
    std::vector<int> vec3(10, 5); // 10 个元素，初始值为 5

    // 使用初始化列表
    std::vector<int> vec4 = {1, 2, 3, 4, 5};

    // 复制构造函数
    std::vector<int> vec5(vec4);

    // 输出 vec4 的内容
    for (int i : vec4) {
        std::cout << i << " ";
    }

    return 0;
}
```

##### 3.常用操作

###### 3.1添加和删除元素

- `push_back`：在末尾添加一个元素。
- `pop_back`：删除末尾的元素。
- `insert`：在指定位置插入一个或多个元素。
- `erase`：删除指定位置的一个或多个元素。
- `clear`：删除所有元素。

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 在末尾添加一个元素
    vec.push_back(6);

    // 删除末尾的元素
    vec.pop_back();

    // 在第二个位置插入 10
    vec.insert(vec.begin() + 1, 10);

    // 删除第三个位置的元素
    vec.erase(vec.begin() + 2);

    // 输出 vec 的内容
    for (int i : vec) {
        std::cout << i << " ";
    }

    return 0;
}
```

###### 3.2 访问元素

- `中括号[]` 和 `at`：访问指定位置的元素。
- `front` 和 `back`：访问第一个和最后一个元素。

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 使用 中括号[] 访问元素
    std::cout << "First element: " << vec[0] << std::endl;

    // 使用 at 访问元素
    std::cout << "Second element: " << vec.at(1) << std::endl;

    // 访问第一个和最后一个元素
    std::cout << "Front element: " << vec.front() << std::endl;
    std::cout << "Back element: " << vec.back() << std::endl;

    return 0;
}
```

###### 3.3 容量相关操作

- `size`：返回当前元素个数。
- `capacity`：返回当前分配的存储空间大小。
- `resize`：调整容器大小。
- `reserve`：预留存储空间，减少重新分配的次数。

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 输出当前大小和容量
    std::cout << "Size: " << vec.size() << std::endl;
    std::cout << "Capacity: " << vec.capacity() << std::endl;

    // 调整大小
    vec.resize(10);
    std::cout << "Size after resize: " << vec.size() << std::endl;

    // 预留存储空间
    vec.reserve(20);
    std::cout << "Capacity after reserve: " << vec.capacity() << std::endl;

    return 0;
}
```

***

#### 4.10.2 模板类array(C++11)

`std::array`是C++标准库中的一个模板类，用于表示固定大小的数组。它在C++11标准中引入，提供了比传统C-style数组更安全和更方便的功能。与`std::vector`不同，`std::array`的大小在编译时确定，不能动态调整。是一个强类型、固定大小的数组容器，提供了比传统C-style数组更好的类型安全性和功能。它支持STL的所有常用操作，使得在编写代码时更加方便和安全。通过使用`std::array`，可以在需要固定大小数组的场景中获得更好的编程体验和更少的错误风险。

我的理解是高级版本的数组。

##### 1. 基本特性

- **固定大小**：`std::array`的**大小在编译时确定**，不能改变，存放在**栈区**。
- **类型安全**：`std::array`封装了传统数组，提供了更安全的操作。
- **STL兼容**：`std::array`支持标准模板库（STL）中的所有常用操作，如迭代器、算法等。

##### 2.创建和初始化

创建和初始化`std::array`有多种方式：

```cpp
#include <array>
#include <iostream>

int main() {
    // 使用列表初始化
    std::array<int, 5> arr1 = {1, 2, 3, 4, 5};

    // 使用默认构造函数，所有元素初始化为默认值
    std::array<int, 5> arr2 = {};

    // 使用std::array的fill方法
    std::array<int, 5> arr3;
    arr3.fill(10);

    // 输出 arr1 的内容
    for (int i : arr1) {
        std::cout << i << " ";
    }

    return 0;
}
```

##### 3.常用操作

###### 3.1 访问元素

- `operator[]` 和 `at`：访问指定位置的元素。
- `front` 和 `back`：访问第一个和最后一个元素。

```cpp
#include <array>
#include <iostream>

int main() {
    std::array<int, 5> arr = {1, 2, 3, 4, 5};

    // 使用 operator[] 访问元素
    std::cout << "First element: " << arr[0] << std::endl;

    // 使用 at 访问元素
    std::cout << "Second element: " << arr.at(1) << std::endl;

    // 访问第一个和最后一个元素
    std::cout << "Front element: " << arr.front() << std::endl;
    std::cout << "Back element: " << arr.back() << std::endl;

    return 0;
}
```

###### 3.2 迭代器支持

`std::array`支持标准的迭代器，允许使用范围for循环和STL算法：

```cpp
#include <array>
#include <iostream>
#include <algorithm>

int main() {
    std::array<int, 5> arr = {5, 4, 3, 2, 1};

    // 使用范围for循环迭代
    for (const auto& elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // 使用标准算法排序
    std::sort(arr.begin(), arr.end());

    // 使用范围for循环输出排序后的结果
    for (const auto& elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

###### 3.3 容量相关操作

- `size`：返回数组的大小。
- `max_size`：返回数组的最大可能大小（与`size`相同）。

```cpp
#include <array>
#include <iostream>

int main() {
    std::array<int, 5> arr = {1, 2, 3, 4, 5};

    // 输出数组大小
    std::cout << "Size: " << arr.size() << std::endl;

    // 输出数组最大可能大小
    std::cout << "Max Size: " << arr.max_size() << std::endl;

    return 0;
}
```

##### 4. 成员函数

- `fill`：用指定值填充数组的所有元素。
- `swap`：交换两个`std::array`对象的内容。

```cpp
#include <array>
#include <iostream>

int main() {
    std::array<int, 5> arr1 = {1, 2, 3, 4, 5};
    std::array<int, 5> arr2 = {6, 7, 8, 9, 10};

    // 使用 fill 填充数组
    arr1.fill(0);

    // 输出填充后的 arr1
    for (const auto& elem : arr1) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // 交换 arr1 和 arr2 的内容
    arr1.swap(arr2);

    // 输出交换后的 arr1 和 arr2
    for (const auto& elem : arr1) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    for (const auto& elem : arr2) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

***

#### 4.10.3 比较数组、vector对象和array对象

当然，以下是对C++中的传统数组、`std::vector`对象和`std::array`对象的比较，以表格形式呈现：

| 特性           | 传统数组               | `std::vector`                          | `std::array`                   |
| -------------- | ---------------------- | -------------------------------------- | ------------------------------ |
| **定义方式**   | `int arr[5];`          | `std::vector<int> vec;`                | `std::array<int, 5> arr;`      |
| **大小**       | 固定，编译时确定       | 动态，可运行时调整                     | 固定，编译时确定               |
| **内存分配**   | 静态或栈上分配         | 动态分配，堆上分配                     | 栈上分配或嵌入到类对象中       |
| **元素访问**   | 通过索引访问，`arr[i]` | 通过索引或迭代器访问，`vec[i]`         | 通过索引或迭代器访问，`arr[i]` |
| **边界检查**   | 无边界检查             | 有边界检查（`at`方法）                 | 有边界检查（`at`方法）         |
| **大小调整**   | 不可调整               | 可动态调整，`push_back`, `resize`      | 不可调整                       |
| **迭代器支持** | 不支持                 | 支持完整的STL迭代器                    | 支持完整的STL迭代器            |
| **初始化**     | 必须手动初始化         | 可以通过构造函数或`push_back`初始化    | 支持列表初始化                 |
| **容量管理**   | 无容量管理             | 有容量管理，`capacity` 和 `reserve`    | 无容量管理                     |
| **赋值操作**   | 需要手动复制           | 支持赋值操作和拷贝构造                 | 支持赋值操作和拷贝构造         |
| **函数参数**   | 传递指针               | 传递引用或指针                         | 传递引用或指针                 |
| **安全性**     | 易出现越界错误         | 较安全，提供边界检查和自动内存管理     | 较安全，提供边界检查           |
| **效率**       | 最高效，但缺乏灵活性   | 相对高效，提供灵活性，适合动态大小场景 | 高效，适合固定大小的需求       |

***

***



## 第五章： 循环和关系表达式

### 5.1 for循环

#### 5.1.1 for循环组成部分

在C++中，`for`循环是一种用于迭代执行代码块的控制结构。它通常用于需要重复执行特定操作，直到满足某个条件的场景。C++中的`for`循环有几种形式，包括传统的`for`循环、范围`for`循环（C++11引入），以及使用STL迭代器的`for`循环。以下是详细讲解和示例：

##### 1. 传统`for`循环

> 基本结构

传统`for`循环的基本结构如下：

```cpp
for (初始化语句; 条件表达式; 迭代语句) {
    // 循环体
}
```

- **初始化语句**：在循环开始前执行一次，用于初始化循环变量。
- **条件表达式**：在每次循环迭代前进行评估，如果结果为`true`，则执行循环体；如果为`false`，则终止循环。
- **迭代语句**：每次循环迭代后执行，用于更新循环变量。

<table><tr><td bgcolor = orange>执行初始化语句->执行一次条件判断表达式->执行循环体操作->执行迭代语句->             然后开始循环过程直到终止(条件判断->循环体->迭代->...) </td></tr></table>

![](.\asset\for循环示意图.png)

> 示例

```cpp
#include <iostream>

int main() {
    for (int i = 0; i < 5; ++i) {
        std::cout << "i = " << i << std::endl;
    }
    return 0;
}
```

在这个例子中，`i`从0开始，每次迭代递增1，直到`i`达到5，循环终止。

* 整个过程中，初始化语句只执行了一次。
* 在执行条件判断语句的时候，C++会强制将结果转换为`true`或者`false`

##### 2. 范围`for`循环（Range-Based For Loop）

C++11引入了范围`for`循环，简化了遍历容器或数组的操作。

> 基本结构

```cpp
for (声明 : 表达式) {
    // 循环体
}
```

- **声明**：用于声明一个循环变量，该变量将被赋值为每次迭代中的元素。
- **表达式**：一个返回范围的对象，如数组、容器等。

> 示例

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    for (int value : vec) {
        std::cout << value << std::endl;
    }

    return 0;
}
```

在这个例子中，`vec`中的每个元素依次赋值给`value`，并在循环体中打印出来。

##### 3. 使用迭代器的`for`循环

当使用STL容器时，迭代器可以用来遍历元素。

> 基本结构

```cpp
for (auto it = container.begin(); it != container.end(); ++it) {
    // 循环体
}
```

- **初始化语句**：初始化一个迭代器，指向容器的起始位置。
- **条件表达式**：检查迭代器是否已到达容器的末尾。
- **迭代语句**：移动迭代器到下一个元素。

> 示例

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << std::endl;
    }

    return 0;
}
```

在这个例子中，`it`是一个指向`vec`中元素的迭代器，每次迭代中`*it`解引用来访问当前元素。

##### 4. `for`循环中的控制语句

> `break`语句

用于提前终止循环。

```cpp
#include <iostream>

int main() {
    for (int i = 0; i < 10; ++i) {
        if (i == 5) {
            break;  // 提前终止循环
        }
        std::cout << "i = " << i << std::endl;
    }
    return 0;
}
```

> `continue`语句

用于跳过本次迭代，继续下一次迭代。

```cpp
#include <iostream>

int main() {
    for (int i = 0; i < 10; ++i) {
        if (i % 2 == 0) {
            continue;  // 跳过本次迭代
        }
        std::cout << "i = " << i << std::endl;
    }
    return 0;
}
```

在这个例子中，`continue`语句跳过了所有偶数，使得`i`为偶数时不打印。

##### 5. 嵌套`for`循环

一个`for`循环可以嵌套在另一个`for`循环中，用于处理多维数组或矩阵等结构。

> 示例

```cpp
#include <iostream>

int main() {
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            std::cout << "i = " << i << ", j = " << j << std::endl;
        }
    }
    return 0;
}
```

在这个例子中，外层循环每执行一次，内层循环将执行完整的一轮。

##### 总结

C++的`for`循环提供了多种灵活的迭代机制，从传统的计数循环到范围`for`循环，再到使用迭代器遍历容器。掌握不同类型的`for`循环及其适用场景，是编写高效、简洁代码的关键。

***

#### 5.1.5 递增运算符（++）和递减运算符（--）

* a++   先返回变量a的值，然后对变量进行递增操作。
* a--   先返回变量a的值，然后对变量进行递减操作。
* ++a 先对变量进行递增操作，然后返回变量a的值。
* --a   先对变量进行递减操作，然后返回变量a的值。

<font color = red>注意：</font> 这种前缀或者后缀的操作只能应用于变量，而不允许应用于表达式。

```c++
(++a)++;                       //是不合法的
```

在 C++ 中，表达式 `(++a)++` 是不合法的。

这是因为 `++a` 是一个前缀递增操作，它会先将 `a` 的值递增，然后返回递增后的值。而后缀递增操作 `++` 应用于 `++a` 的结果，这是不允许的。因为后缀递增操作符 `++` **要求应用于一个可修改的左值（lvalue）**，而 `++a` 的结果是一个临时的右值（rvalue），它无法被修改。因此，将后缀递增操作符 `++` 应用于 `++a` 是不合法的。

***

#### 5.1.6 副作用和顺序点

在C++编程中，副作用和顺序点是两个重要的概念，理解它们有助于编写更加可靠和高效的代码。

##### 1.副作用（Side Effect）

**副作用**是指在执行表达式过程中对程序状态的任何修改。这包括但不限于：

- 修改变量的值
- 进行输入或输出操作
- 分配或释放内存

副作用通常通过赋值操作、递增/递减运算符、函数调用等引入。

>  示例

```cpp
#include <iostream>

int main() {
    int a = 5;

    // 副作用：修改变量 a 的值
    a = 10;

    // 副作用：递增运算符修改变量 a 的值
    ++a;

    // 副作用：输出操作
    std::cout << "a = " << a << std::endl;

    return 0;
}
```

在这个例子中，`a = 10` 和 `++a` 都产生了副作用，因为它们修改了变量 `a` 的值。`std::cout` 也是副作用，因为它影响了程序的输出状态。

##### 2. 顺序点（Sequence Point）

**顺序点**是程序执行中的某个特定点，在此点之前的所有副作用都已经执行完毕，并且在此点之后的所有副作用尚未开始。顺序点定义了表达式的求值顺序，从而避免未定义行为。

C++11 引入了顺序点的替代概念，称为**序列**（sequencing），分为**顺序之前**（sequenced before）和**顺序之后**（sequenced after）。但在理解基础概念时，传统的顺序点仍然是一个有用的术语。

> 常见顺序点

1. **完整表达式的末尾**：如语句结束处、控制结构的判断条件等。
2. **逻辑与（`&&`）和逻辑或（`||`）运算符**：左侧表达式的求值完成后才会求值右侧表达式。
3. **逗号运算符**：左侧表达式的求值和副作用完成后才会求值右侧表达式。
4. **函数调用**：所有实参的求值完成之后再执行函数体。

> 示例

```cpp
#include <iostream>

int main() {
    int a = 1, b = 2;

    // 顺序点：逻辑与运算符的左侧求值完成后才会求值右侧
    if (a == 1 && b == 2) {
        std::cout << "Both conditions are true" << std::endl;
    }

    // 顺序点：逗号运算符左侧求值完成后才会求值右侧
    a = (b = 3, b + 1);

    std::cout << "a = " << a << std::endl; // 输出 a = 4

    return 0;
}
```

在这个例子中，逻辑与运算符 `&&` 和逗号运算符 `,` 都引入了顺序点，确保表达式按预期顺序求值。

##### 3. 副作用和顺序点的关系

理解副作用和顺序点之间的关系对于避免未定义行为非常重要。未定义行为通常发生在表达式中有多个副作用并且缺乏明确的求值顺序时。

> 未定义行为示例

```cpp
#include <iostream>

int main() {
    int i = 0;

    // 未定义行为：在同一表达式中，i 被修改多次且没有明确的求值顺序
    int result = i++ + ++i;

    std::cout << "result = " << result << std::endl;

    return 0;
}
```

在这个例子中，`i++ + ++i` 产生未定义行为，因为 `i` 在同一个表达式中被修改了多次，且没有明确的顺序点来保证求值顺序。

***

#### 5.1.7 前缀后缀以及递增递减运算符以及指针的优先级关系

前缀递增、前缀递减和解除引用的运算符的优先级相同，以**从左往右**的方式进行结合。后缀递增和后缀递减的优先级相同，但比前缀运算符的优先级高，这两个运算符以**从左往右**的方式进行结合。

例如，在表达式 `*++ptr` 中，先执行 `++ptr`，然后再执行解除引用操作 `*`。

总结：后缀运算比前缀运算高，其他都是默认从左往右。

***

#### 5.1.10 复合语句（代码块）

复合语句（Compound Statement），也称为代码块（Block），是 C++ 中的一个重要概念，它允许将多个语句组合在一起，形成一个逻辑上的整体。在C++中，用<code> {} </code> 来包括一个代码块。

**作用域**：复合语句中声明的变量在复合语句内可见，出了复合语句则不可见。

**代码结构化**：复合语句可以将多个语句组织在一起，使得代码更加结构化和易读。

**局部变量**：可以在复合语句中声明局部变量，这些变量只在复合语句内部可见，出了复合语句就无法访问。

**逻辑分组**：复合语句可以将相关的语句组织在一起，形成一个逻辑上的整体，提高代码的可读性和可维护性。

```cpp
#include <iostream>

int main() {
    int x = 5;

    // 复合语句
    {
        int y = 10;
        std::cout << "x + y = " << x + y << std::endl;
    }

    // 复合语句外部无法访问 y
    // std::cout << "y = " << y << std::endl; // Error: 'y' was not declared in this scope

    return 0;
}
```

在这个示例中，复合语句内部声明了变量 `y`，在复合语句外部无法访问 `y`。

同样，在复合语句中允许声明一个和外部语句块一样名称的变量，如这里就可以声明一个<code> int x= 30 </code>放在复合语句中，那么它对于这个复合语句块中的代码而言，就覆盖了外部语句块的内容

```cpp
 int x = 5;
    {
        int x = 10;                                   // 复合语句
        std::cout << "x  = " << x  << std::endl;      //这里输出是10
    }
std::cout << "x  = " << x  << std::endl;              //这里输出是5
```

对于这个复合语句中的x，仅仅在复合语句中生效。

***

#### 5.1.11 其他语法技巧-------逗号运算符

逗号运算符（`,`）在C++中是一个二元运算符，它用于连接两个表达式，并按顺序执行它们，然后返回第二个表达式的值。逗号运算符的一般形式是 `expr1, expr2`，其中 `expr1` 和 `expr2` 是两个表达式。

1. **顺序执行**：逗号运算符会按顺序执行它连接的两个表达式，首先执行 `expr1`，然后执行 `expr2`。

2. **返回值**：逗号运算符的返回值是 `expr2` 的值。这意味着整个表达式的值是 `expr2` 的值。

3. **副作用**：逗号运算符执行过程中，会计算 `expr1` 和 `expr2`，因此如果这两个表达式有副作用，都会被执行。

> 示例：

```cpp
int main() {
    int a = 1, b = 2, c = 3;
    // 逗号运算符连接两个表达式，首先执行表达式 a = b, 然后执行表达式 c = b
    int result = (a = b, c = b + 1);
    std::cout << "result = " << result << std::endl; // 输出 result = 3
    return 0;
}
```

在这个示例中，`(a = b, c = b + 1)` 中的逗号运算符首先执行 `a = b`，然后执行 `c = b + 1`，最终 `result` 的值是 `c` 的值，即 `3`。

逗号运算符常用于 `for` 循环和函数调用参数列表中，以在单个语句中执行多个表达式。例如：

```cpp
for(int i=0, j = ruan.size()-1;j<i;--i，++j){
    ruan[i] = ruan[j];
}
```

***

#### 5.1.12 关系表达式

C++中的关系运算符用于比较两个值，并确定它们之间的关系。这些运算符返回一个布尔值（`true`或`false`），表示比较的结果是否成立。

| 操作符 | 含义     |
| ------ | -------- |
| ==     | 等于     |
| !=     | 不等于   |
| >      | 大于     |
| <      | 小于     |
| >=     | 大于等于 |
| <=     | 小于等于 |

赋值、比较和可能犯的错误: 把==和= 弄混淆。

***

#### 5.1.14 C风格字符串的比较

C语言中，使用C风格字符串时，比较字符串通常使用的是标准库函数`strcmp()`或者`strncmp()`。说白了就是给字符串比较大小（<font size=2 color=red>字符是按照系统编码来比较的</font>），通常用于判断两个字符串是否相等。

1. **strcmp()函数**：
   
   - `strcmp()`函数用于比较两个字符串的大小，它返回一个整数值，表示两个字符串的比较结果。
   - 如果字符串相等，则返回0；如果第一个字符串小于第二个字符串，则返回一个负数；如果第一个字符串大于第二个字符串，则返回一个正数。
   - `strcmp()`函数的原型如下：
     ```c
     int strcmp(const char *str1, const char *str2);
     ```
   - 示例：
     ```c
     #include <stdio.h>
     #include <string.h>
     
     int main() {
         char str1[] = "hello";
         char str2[] = "world";
         int result = strcmp(str1, str2);
         if (result == 0) {
             printf("两个字符串相等.\n");
         } else if (result < 0) {
             printf("str1 比 str2 小.\n");
         } else {
             printf("str1 比 str2 大.\n");
         }
         return 0;
     }
     ```
   
2. **strncmp()函数**：
   
   - `strncmp()`函数与`strcmp()`类似，但它只比较字符串的前n个字符。（**实用**）
   - 它的原型如下：
     ```c
     int strncmp(const char *str1, const char *str2, size_t n);
     ```
   - 示例：
     ```c
     #include <stdio.h>
     #include <string.h>
     
     int main() {
         char str1[] = "hello";
         char str2[] = "world";
         int result = strncmp(str1, str2, 3);
         if (result == 0) {
             printf("前三个字符相等.\n");
         } else if (result < 0) {
             printf("str1前三个字符小于str2的.\n");
         } else {
             printf("str1前三个字符大于str2的.\n");
         }
         return 0;
     }
     ```

这些函数是C语言中比较C风格字符串的常用方法。在比较字符串时，务必要注意字符串结尾的空字符（'\0'）以确保比较的正确性。

***

#### 5.1.15 比较string类字符串

在C++中，比较`string`类字符串可以使用多种方法，包括重载的比较运算符、成员函数和标准库函数等。

##### 1. 重载的比较运算符：

`string`类重载了比较运算符（`==`、`!=`、`<`、`>`、`<=`、`>=`），允许**直接比较**两个`string`对象的**大小关系**。

示例：
```cpp
#include <iostream>
#include <string>

int main() {
    std::string str1 = "hello";
    std::string str2 = "world";
    if (str1 == str2) {
        std::cout << "str1 equals str2" << std::endl;
    } else if (str1 < str2) {
        std::cout << "str1 is less than str2" << std::endl;
    } else {
        std::cout << "str1 is greater than str2" << std::endl;
    }
    return 0;
}
```

##### 2. 成员函数compare()：

`string`类提供了成员函数`compare()`，可以用于比较两个`string`对象的大小关系。它返回一个整数值，表示两个字符串的比较结果。

示例：
```cpp
#include <iostream>
#include <string>
int main() {
    std::string str1 = "hello";
    std::string str2 = "world";
    int result = str1.compare(str2);

    if (result == 0) {
        std::cout << "str1 equals str2" << std::endl;
    } else if (result < 0) {
        std::cout << "str1 is less than str2" << std::endl;   //小于0 就是比参数小
    } else {
        std::cout << "str1 is greater than str2" << std::endl;   //大于0 就是比参数大
    }
    return 0;
}
```

##### 3. 标准库函数：

如果你更倾向于使用标准库函数，你可以使用`std::lexicographical_compare()`函数，它可以比较两个范围内的元素（包括字符串）的字典序。

示例：
```cpp
#include <iostream>
#include <string>
#include <algorithm>

int main() {
    std::string str1 = "hello";
    std::string str2 = "world";

    if (std::lexicographical_compare(str1.begin(), str1.end(), str2.begin(), str2.end())) {
        std::cout << "str1 is less than str2" << std::endl;
    } else {
        std::cout << "str1 is greater than or equal to str2" << std::endl;
    }

    return 0;
}
```

无论选择哪种方法，都能够方便地比较`string`类字符串的大小关系。

***

### 5.2 while循环

#### 5.2.1 while循环语句讲解

`while` 循环语句是 C++ 中的一种迭代结构，它允许你重复执行一段代码块，直到给定的条件变为假为止。`while` 循环的基本语法如下：

```cpp
while (condition) {
    // 在条件为真时执行的代码块
}
```

在 `while` 循环中，首先会对条件进行求值。如果条件为真，则执行循环体中的代码块；如果条件为假，则退出循环，继续执行循环后面的代码。

![](.\asset\while循环示意图.png)

> 示例：

```cpp
#include <iostream>
int main() {
    int i = 0;
    // 当 i 小于 5 时，循环执行
    while (i < 5) {
        std::cout << i << " ";
        i++; // 更新循环控制变量，避免无限循环
    }
    return 0;
}
```

在这个示例中，当 `i` 的值小于5时，循环会一直执行。每次迭代，都会打印 `i` 的值，然后递增 `i`。当 `i` 的值达到5时，条件变为假，循环终止。

`while` 循环非常灵活，因为条件可以是任何可以转换为布尔值的表达式。要**确保循环能够结束**，通常需要在循环体中修改循环控制变量，以便最终使条件为假，否则会产生无限循环。

